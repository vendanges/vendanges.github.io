<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="theme-color" content="#33474d">
	<title>Spring cloud Ribbon or RestTemplate and Feign | 琼瑶</title>
	<link rel="stylesheet" href="/css/style.css" />
	
      <link rel="alternate" href="/atom.xml" title="琼瑶" type="application/atom+xml">
    
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

	<header class="header">
		<nav class="header__nav">
			
				<a href="/" class="header__link" style="color: #fff">Home</a>
			
				<a href="/archives" class="header__link" style="color: #fff">Archive</a>
			
				<a href="/about" class="header__link" style="color: #fff">About</a>
			
		</nav>
		<!-- <h1 class="header__title"><a href="/">琼瑶</a></h1> -->
		<h1 class="header__title"><a href="/"><img style="width: 290px;" src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/202204152017786.png"></a></h1>
		<h2 class="header__subtitle">梦入琼楼寒有月，行过石树冻无烟</h2>
	</header>

	<main>
		<article>
	
		<h1>Spring cloud Ribbon or RestTemplate and Feign</h1>
	
	<div class="article__infos">
		<span class="article__date">2022-04-21</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-none-link" href="/tags/java/" rel="tag">java</a> <a class="article__tag-none-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a>
			</span>
		
	</div>

	

	
		<p>首先我们只需要知道在 Ribbon 和 Feign 或 RestTemplate 中，Ribbon 主要基于 HTTP和TCP出来进行客户端的负载均衡，他是由 Netfix 公司所开源项目 Netfix OSS 的一部分，可自动与 Netfix Server Discover 也就是 Eureka 进行交互。</p>
<blockquote>
<p>Ribbon 是不可以独立部署的，Spring cloud Ribbon 是基于 Ribbon 的实现。基于了轮廓、随机等规则自动调用服务，当然除此之外还可以根据自身需要来定义均衡算法。</p>
</blockquote>
<p>而 Feign 和 RestTemplate 都是用于实现服务发现， Feign 主要是声明试的 WebService 客户端，为我们提供了一个快捷、优雅的调用 HTTP API。后者则是需要服务的 IP地址等这些信息来实现各个服务之间的通信调用，区别就是 Feign 会 <strong>比 RestTemplate 简洁和优雅许多</strong>。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210621200441.png"><br>在仔细讲解 Ribbon 与 Feign 或 RestTemplate 之前，他们都是涉及或实现出负载均衡这个功能，因此负载均衡在这里尤为重要。</p>
<p>负载均额（Load Balance）从字面意思上我们可以理解为当一个数据请求时可以分摊多个单元进行分流，通常负载均衡会分为服务器端负载均衡以及客户端负载均衡两种。</p>
<h3 id="服务器端负载均衡"><a href="#服务器端负载均衡" class="headerlink" title="服务器端负载均衡"></a>服务器端负载均衡</h3><p>服务器端负载均衡主要是应对高并发和服务器端扩容的重要方法之一，负载均衡也通常讲的是服务器端负载均衡。服务器端的负载均衡主要通过在服务器与客户端之间添加负载均衡器进行实现，主要分为硬件和软件负载均衡，这里我们主要介绍软件的负载均衡。</p>
<blockquote>
<p> 无论是软件的负载均衡还是硬件的负载均衡均维护着一个正常服务清单，通过心跳机制来删除出现故障的服务节点，也可以通过他来恢复服务节点。</p>
</blockquote>
<p>软件负载均衡主要是在普通的服务器上安装具有负载均衡的软件来实现请求的分发，进而实现负载均衡，需要注意的是服务器端的 “正常服务提供者清单” 是存储在负载均衡器中的。</p>
<h3 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h3><p>客户端负载均衡与服务器端负载均衡相差无几，他们的区别主要是客户端他本身拥有 “正常服务提供者清单”，在客户端负载均衡中。所有客户端管理都管理着一份自己需要访问的服务提供者清单，而这些清单大多数从服务中心进行获取。</p>
<h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210622080816.png"><br>Ribbon 是 Netfix 公司所开源项目 Netfix OSS 的一部分，主要提供一个客户端负载均衡的云库。他主要基于 HTTP 和 TCP 的客户端负载均衡组件，之后的 Spring cloud Ribbon 是一个基于 Ribbon 实现，主要特点是可以根据需要自定义负载均衡算法。</p>
<blockquote>
<p>Choose Server 是负载均衡策略中 “线性轮询策略（Round Robin Ruie）” 工作流程内的第三步骤，其作用是获取服务列表中取服务进行请求，如果连续十次都没有获取到服务则报错。</p>
</blockquote>
<p>从上图中我们可以看到，Ribbon 本身所维护着 正常服务提供者清单的有效性，如果通过 <code>ChooseServer</code> 不可用，则会重新从服务中心获取有效的服务提供者清单来进行更新。</p>
<h3 id="Ribbon-接口类型"><a href="#Ribbon-接口类型" class="headerlink" title="Ribbon 接口类型"></a>Ribbon 接口类型</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210623161907.png"></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Type Info</th>
<th>Bean Name</th>
<th>Class Name</th>
</tr>
</thead>
<tbody><tr>
<td>IClientConfig</td>
<td><strong>用于读取配置</strong>，实现类是 <code>DefaultClientConfigIcmpl</code>，而默认值也是该类</td>
<td>ribbonClientConfig</td>
<td>DefaultClientConfigIcmpl</td>
</tr>
<tr>
<td>IRule</td>
<td><strong>负责处理负载均衡规则</strong>，实现类是 <code>ZoneAvoidanceRule</code> 默认通过他来选择实例，步骤是：</td>
<td>ribbonRule</td>
<td>ZoneAvoidanceRule</td>
</tr>
<tr>
<td></td>
<td>1.ServerList 获取所有可用的服务提供者列表</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>2.ServerListFileter 过滤一部分服务提供者地址</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>3.最后在剩下的地址中通过 IRule 选择一台服务器</td>
<td></td>
<td></td>
</tr>
<tr>
<td>IPing</td>
<td><strong>用来筛选掉无法访问的实例</strong></td>
<td>ribbonPing</td>
<td>DummyPing</td>
</tr>
<tr>
<td>ServerList <code>&lt;server&gt;</code></td>
<td><strong>用于获取服务提供者地址列表</strong>，可以是一组固定地址也可是服务中心中定期查询服务提供者的地址列表</td>
<td>ribbonServerList</td>
<td>ConfigurationBasedServerList</td>
</tr>
<tr>
<td>ServerListFileter <code>&lt;server&gt;</code></td>
<td>在原始服务提供者地址列表中，<strong>通过使用一定的策略过滤一部分不符合条件的地址</strong>（当动态使用 ServerList时使用）</td>
<td>ribbonServerListFilter</td>
<td>ZonePrefernenceServerListFilter</td>
</tr>
<tr>
<td>ILoadBalancer</td>
<td>可通过负载均衡中选择一个服务器，并通过标记暂停服务的服务器，一可以获取所有已知的服务器提供者列表</td>
<td>ribbonLoadBalancer</td>
<td>ZoneAwareLoadBalancer or BaseLoadBalancer</td>
</tr>
<tr>
<td>ServerListUpdater</td>
<td><strong>用于ServerList的更新</strong>，当服务中心的服务提供者发生变化的时候，ServerList 会根据 PollingServerListUpdater 来实现定时更新服务提供者列表</td>
<td>ribbonServerListUpdate</td>
<td>PollingServerListUpdater</td>
</tr>
</tbody></table>
<h3 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h3><p>负载均衡器很多都是通过 Ribbon 接口类型来进行实现具体的负载均衡 Bean 如：</p>
<p>| Bean | Type | Class Name |<br>| — | — | — | — |<br>| LoadBalancerClient | ILoad Balancer | RibbonLoadBalancerClient |<br>| AbstractLoadBalancer | ILoad Balancer | AbstractLoadBalancer |</p>
<h4 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h4><p>在初始化时 <code>execute()</code> 方法会通过ILoadBalancer 来从服务中心获取服务提供者地址列表，并每 10s 来检测一下服务的可用性。如果服务端可用性发生改变，或者数量不一致，那么 <code>RibbonLoadBanlancer</code> 会从注册中心更新服务提供者地址列表，之后可以根据 IRule 来进行负载均衡。</p>
<p>LoadBanlancer主要的职责是添加服务器、选择服务器、获取所有的服务器列表、获取可用的服务提供者列表等。</p>
<table>
<thead>
<tr>
<th>Method Name</th>
<th>Method Info</th>
</tr>
</thead>
<tbody><tr>
<td><code>addServers(List&lt;Server&gt; newServers)</code></td>
<td>向服务器初始列表中增加新的服务提供者地址列表</td>
</tr>
<tr>
<td><code>chooseServer(Object key)</code></td>
<td>从负载均衡器中选择一个服务器</td>
</tr>
<tr>
<td><code>markServerDown(Server server)</code></td>
<td>通知或标记已经暂停服务的服务器</td>
</tr>
<tr>
<td><code>getReachableServers()</code></td>
<td>返回获取到可用的服务提供者列表</td>
</tr>
<tr>
<td><code>getAllServers</code></td>
<td>获取所有看到服务提供者列表</td>
</tr>
</tbody></table>
<p>Load Balancer 主要用于定义软件负载均衡的操作接口，一个典型的负载负载均衡实现需要一组服务器进行。通常一个方法来标记特定的服务器不循环，一个调用将现有的服务器列表中选择一个服务器来进行提供服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  定义软件负载均衡的操作接口，一个典型的负载负载均衡实现需要一组服务器进行。通常一个方法来标记特定的服务器不循环</span></span><br><span class="line"><span class="comment"> * 一个调用将现有的服务器列表中选择一个服务器来进行提供服务。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stonse</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILoadBalancer</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 向服务器初始列表中增加新的服务提供者地址列表（host:port）</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> 添加新服务提供者</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addServers</span><span class="params">(List&lt;Server&gt; newServers)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从负载均衡器中选择一个服务器</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> 负载均衡器将可用于确定返回那个服务器的对象，如为空则</span></span><br><span class="line"><span class="comment">	 *         负载均衡器将不会使用此参数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 选择服务器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> Server <span class="title function_">chooseServer</span><span class="params">(Object key)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 由负载均衡器的客户端掉应来通知某个服务器暂停服务，否则 ILoadBalancer 依然认为他可以提供服务</span></span><br><span class="line"><span class="comment">	 * 直到下一次检测的周提</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> 标记已经暂停服务的服务器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markServerDown</span><span class="params">(Server server)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@deprecated</span>    getServerList 在 2016-01-20 就被弃用，取而代之的则是 getReachableServers 以及 getAllServer API。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> 如果为 true 则只应用返回可用的服务器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;Server&gt; <span class="title function_">getServerList</span><span class="params">(<span class="type">boolean</span> availableOnly)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回获取到可用的服务提供者列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Server&gt; <span class="title function_">getReachableServers</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取所有看到服务提供者列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;Server&gt; <span class="title function_">getAllServers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="AbstractLoadBalancer"><a href="#AbstractLoadBalancer" class="headerlink" title="AbstractLoadBalancer"></a>AbstractLoadBalancer</h4><p>Abstract Load Balancer 是 ILoad Balancer 的实现类，他包含了大多数负载均衡实现所需要的功能，典型的是 Load Balancer 的结构：</p>
<ol>
<li>基于特定的标准可以分时段的服务提供者信息列表</li>
<li>通过规则的定义和实现负载均衡的策略类</li>
<li>定义并实现一种机制来确定服务提供者表单中的节点、可用性的类。</li>
</ol>
<p>在这三类中，Abstract Load Balancer 类实现了服务提供者地址列表分组的作用，被 服务器组（ServerGroup） 来定义：</p>
<table>
<thead>
<tr>
<th>Method name</th>
<th>Method info</th>
</tr>
</thead>
<tbody><tr>
<td>ServerGroup</td>
<td></td>
</tr>
<tr>
<td></td>
<td>ALL：所有服务</td>
</tr>
<tr>
<td></td>
<td>STATUS_UP：正常运行的服务</td>
</tr>
<tr>
<td></td>
<td>STATUS_NOT_UP：下线或崩溃的服务</td>
</tr>
<tr>
<td>chooseServer</td>
<td></td>
</tr>
<tr>
<td></td>
<td>从负载均衡中选择一个服务器</td>
</tr>
<tr>
<td>getServerList(ServerGroup serverGroup)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>获取负载均衡中所有服务的实例列表</td>
</tr>
<tr>
<td>getLoadBalancerStats()</td>
<td></td>
</tr>
<tr>
<td></td>
<td>从 Load Balancer 来获取每个服务的所有细节统计信息</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractLoadBalancer contains features required for most loadbalancing</span></span><br><span class="line"><span class="comment"> * implementations.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * An anatomy of a typical LoadBalancer consists of 1. A List of Servers (nodes)</span></span><br><span class="line"><span class="comment"> * that are potentially bucketed based on a specific criteria. 2. A Class that</span></span><br><span class="line"><span class="comment"> * defines and implements a LoadBalacing Strategy via &lt;code&gt;IRule&lt;/code&gt; 3. A</span></span><br><span class="line"><span class="comment"> * Class that defines and implements a mechanism to determine the</span></span><br><span class="line"><span class="comment"> * suitability/availability of the nodes/servers in the List.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stonse</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractLoadBalancer</span> <span class="keyword">implements</span> <span class="title class_">ILoadBalancer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ServerGroup</span>&#123;</span><br><span class="line">        ALL,</span><br><span class="line">        STATUS_UP,</span><br><span class="line">        STATUS_NOT_UP        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * delegate to &#123;<span class="doctag">@link</span> #chooseServer(Object)&#125; with parameter null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">chooseServer</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> chooseServer(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * List of servers that this Loadbalancer knows about</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverGroup Servers grouped by status, e.g., &#123;<span class="doctag">@link</span> ServerGroup#STATUS_UP&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Server&gt; <span class="title function_">getServerList</span><span class="params">(ServerGroup serverGroup)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Obtain LoadBalancer related Statistics</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> LoadBalancerStats <span class="title function_">getLoadBalancerStats</span><span class="params">()</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="BaseLoadBalancer"><a href="#BaseLoadBalancer" class="headerlink" title="BaseLoadBalancer"></a>BaseLoadBalancer</h5><p>Base Load Balancer 类是 Abstract Load Balancer 的实现类或工具类，他可以用一个 List 集合（AllServerList）来保存所有服务实例，之后用另一个 List 保存（UpServerList）当前有效的服务实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Monitor(name = PREFIX + &quot;AllServerList&quot;, type = DataSourceType.INFORMATIONAL)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> List&lt;Server&gt; allServerList = Collections</span><br><span class="line">        .synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Server&gt;());</span><br><span class="line"><span class="meta">@Monitor(name = PREFIX + &quot;UpServerList&quot;, type = DataSourceType.INFORMATIONAL)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> List&lt;Server&gt; upServerList = Collections</span><br><span class="line">        .synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Server&gt;());</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Method name</th>
<th>Method info</th>
</tr>
</thead>
<tbody><tr>
<td>IpingStrategy</td>
<td>用于定义检查服务的策略，将 ping 所有的服务器（如果执行的很慢可能是你有大量的服务器在此集群中）</td>
</tr>
<tr>
<td>chooseServer</td>
<td>调用 rule 类中的 <code>choose</code> 方法来选择服务器对象（如果没有则返回 null）</td>
</tr>
<tr>
<td>PingTask()</td>
<td>每 x 秒运行一次定时器任务，检查服务器列表中每个服务器&#x2F;节点的状态（默认为 1000s）</td>
</tr>
<tr>
<td>markServerDown()</td>
<td>用于标注服务是否有效（mark Server Down called for server）</td>
</tr>
<tr>
<td>getReachableServer()</td>
<td>获取所有有效的服务实例列表</td>
</tr>
<tr>
<td>getAllServer()</td>
<td>拥有获取所有服务器实例列表</td>
</tr>
<tr>
<td>addServer()</td>
<td>向负载均衡器中添加一个新的服务实例列表</td>
</tr>
</tbody></table>
<p>除此之外，Base Load Balancer 类中的子类 <code>DynamicServerListLoadBalancer</code> 以及 <code>ZoneAwareLoadBalancer</code> 作为 <code>DynamicServerListLoadBalancer</code> 的子类，都实现了了一些能力，分别为：</p>
<p><strong>DynamicServerListLoadBalancer</strong><br>在负载均衡器的基础上做了进一步的扩展，可以在服务实例清单在运行时的动态更新的实现，以及还提供了一个过滤器标准来过滤掉不符合所需标准的服务器。</p>
<h3 id="Ribbon-Ping-的实现"><a href="#Ribbon-Ping-的实现" class="headerlink" title="Ribbon Ping 的实现"></a>Ribbon Ping 的实现</h3><p>在上述介绍中，我们都设计到了 Ping 或 “心跳” 这个概念，负载均衡中 Ping 机制主要用于检测服务提供者的有效性。<strong>他会每隔一段时间执行 Ping 来判断服务器是否存活</strong> ，而这些工作都将由 IPing 和他的实现类来负责（Ribbon 默认实现类是 DummyPing，但需要注意的是默认情况下不会激活 Ping 机制）。</p>
<table>
<thead>
<tr>
<th>Class Name</th>
<th>Class Info</th>
</tr>
</thead>
<tbody><tr>
<td>DummyPing</td>
<td>虚拟的 Ping 实现，当确定服务器活着的时候会返回 <code>true</code></td>
</tr>
<tr>
<td>NoOpPing</td>
<td>设么都不做直接返回 <code>true</code></td>
</tr>
<tr>
<td>PingConstant</td>
<td>IPing 的实现类，他用于返回任何设置的内容，true 或 false（通常只要常量参数为 true 为服务实例存活，否则为失效）</td>
</tr>
</tbody></table>
<h4 id="DummyPing"><a href="#DummyPing" class="headerlink" title="DummyPing"></a>DummyPing</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.client.config.IClientConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default simple implementation that marks the liveness of a Server</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stonse</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DummyPing</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalancerPing</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DummyPing</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">(Server server)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NoOpPing"><a href="#NoOpPing" class="headerlink" title="NoOpPing"></a>NoOpPing</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * No Op Ping</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stonse</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoOpPing</span> <span class="keyword">implements</span> <span class="title class_">IPing</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">(Server server)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PingConstant"><a href="#PingConstant" class="headerlink" title="PingConstant"></a>PingConstant</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A utility Ping Implementation that returns whatever its been set to return</span></span><br><span class="line"><span class="comment"> * (alive or dead)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stonse</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PingConstant</span> <span class="keyword">implements</span> <span class="title class_">IPing</span> &#123;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">constant</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConstant</span><span class="params">(String constantStr)</span> &#123;</span><br><span class="line">				constant = (constantStr != <span class="literal">null</span>) &amp;&amp; (constantStr.toLowerCase().equals(<span class="string">&quot;true&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConstant</span><span class="params">(<span class="type">boolean</span> constant)</span> &#123;</span><br><span class="line">				<span class="built_in">this</span>.constant = constant;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getConstant</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> constant;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">(Server server)</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> constant;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p>AbstractLoadBalancerRule 是一个 <code>IRule</code> 的继承，他本身则是一个负载均衡策略的抽象类，而 IRule 主要定义了 <code>ILoadBalancer</code> ，其最为核心的方法为 <code>choose()</code>，这是用于选择服务器对象（服务实例），如过没有将会返回 null。</p>
<p>而定义 <code>IRule</code> 主要的目的第一就是为了辅助负载均衡器（<code>ILoadBalancer</code>）<strong>来通过负载均衡策略选择合适的服务实例</strong>，其默认使用的是 <strong>九大负载均衡</strong> 策略中的 <code>线性轮询策略（RoundRobinRule）</code>。</p>
<h4 id="线性轮询策略（Round-Robin-Rule）"><a href="#线性轮询策略（Round-Robin-Rule）" class="headerlink" title="线性轮询策略（Round Robin Rule）"></a>线性轮询策略（Round Robin Rule）</h4><p>由于 Round Robin Rule 是 ILoadBalancer 默认采用的负载均衡策略，因此也和他的流程非常符合，与此同时他还是作为著名的负载均衡策略，他主要定义了 <code>AVAILABLE_ONLY_SERVERS（仅可用服务器）</code>、<code>ALL_SERVERS（所有服务器）</code> 两个状态。</p>
<ol>
<li><code>choose(ILoadBalancer lb, Object key)</code> 方法从负载均衡中选择一个服务器并计数，<strong>如果没有则会返回</strong>：<code>“no load balancer”</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="literal">null</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;no load balancer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>incrementAndGetModulo</code> 方法会通过<code>serverCount</code> 函数来请求 <code>allServers（所有服务器）</code>，而 <code>incrementAndGetModulo</code> 方法则会获取下一个索引，也就是说 <strong>获取所有服务器，并从 0 的基础上 +1</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">incrementAndGetModulo</span><span class="params">(<span class="type">int</span> modulo)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> nextServerCyclicCounter.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> (current + <span class="number">1</span>) % modulo;</span><br><span class="line">        <span class="keyword">if</span> (nextServerCyclicCounter.compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最后通过 <code>choose(Object key)</code> 通过索引去服务列表获取服务，如果连续 <strong>10次没有获取到服务</strong>，则会返回: “No available alive servers after 10 tries from load balancer”。假设 <code>可达服务器（reachableServers）</code> 或 <code>服务器总数（allServers）</code> 为 0，则会输出: “No up servers available from load balancer” 错误。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (server == <span class="literal">null</span> &amp;&amp; count++ &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        List&lt;Server&gt; reachableServers = lb.getReachableServers();</span><br><span class="line">        List&lt;Server&gt; allServers = lb.getAllServers();</span><br><span class="line">        <span class="type">int</span> <span class="variable">upCount</span> <span class="operator">=</span> reachableServers.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">serverCount</span> <span class="operator">=</span> allServers.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((upCount == <span class="number">0</span>) || (serverCount == <span class="number">0</span>)) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;No up servers available from load balancer: &quot;</span> + lb);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextServerIndex</span> <span class="operator">=</span> incrementAndGetModulo(serverCount);</span><br><span class="line">        server = allServers.get(nextServerIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Transient. */</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;</span><br><span class="line">            <span class="keyword">return</span> (server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Next.</span></span><br><span class="line">        server = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;No available alive servers after 10 tries from load balancer: &quot;</span></span><br><span class="line">                + lb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重试策略（Retry-Rule）"><a href="#重试策略（Retry-Rule）" class="headerlink" title="重试策略（Retry Rule）"></a>重试策略（Retry Rule）</h4><p>重试策略（Retry Rule）是 Rule 的级联，他采用 Round Robin Rule的 <code>choose()</code>方法来获取服务器实例，<code>最大重试次数（maxRetryMillis）</code> 是 <strong>500</strong>，因此他在选择实例和重试方法是：</p>
<blockquote>
<p>级联（cascade）在计算机科学中指多个对象之间一对多的映射关系，可以理解为一张表 A 用于存放学生所在班级（姓名、性别、年龄）而姓名作为主键，而另一张表 B 存放着楼层住户信息（姓名、性别）他们之间通过 <strong>姓名、年龄</strong> 来作为级联</p>
</blockquote>
<ol>
<li><p>如果通过 <code>choose()</code> 方法获取服务器实例正常，则回答并返回数据</p>
</li>
<li><p>假设超过了 <code>最大的重试次数（maxRetryMillis）</code> 没有获取到 “活着的服务器”，则返回 null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((answer == <span class="literal">null</span>) || (!answer.isAlive())) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后如果没有活着的服务回答在当前时间小于 <code>500 ms</code> 的情况下，则会不断的在这时间段重试。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((answer == <span class="literal">null</span>) || (!answer.isAlive()))</span><br><span class="line">		&amp;&amp; (System.currentTimeMillis() &lt; deadline)) &#123;</span><br><span class="line">	<span class="comment">/* pause and retry hoping it&#x27;s transient */</span></span><br><span class="line">	Thread.yield();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加权响应时间策略（WeightedResponseTimeRule）"><a href="#加权响应时间策略（WeightedResponseTimeRule）" class="headerlink" title="加权响应时间策略（WeightedResponseTimeRule）"></a>加权响应时间策略（WeightedResponseTimeRule）</h4><p>WeightedResponseTimeRule 是 <code>RoundRobinRule</code> 的延伸，对一些功能进行了扩展、可以根据服务实例的运行情况计算出服务实例的权重，之后进行服务实例的挑选。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// get hold of the current reference in case it is changed from the other thread</span></span><br><span class="line">        List&lt;Double&gt; currentWeights = accumulatedWeights;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Server&gt; allList = lb.getAllServers();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">serverCount</span> <span class="operator">=</span> allList.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (serverCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">serverIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// last one in the list is the sum of all weights</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">maxTotalWeight</span> <span class="operator">=</span> currentWeights.size() == <span class="number">0</span> ? <span class="number">0</span> : currentWeights.get(currentWeights.size() - <span class="number">1</span>); </span><br><span class="line">        <span class="comment">// No server has been hit yet and total weight is not initialized</span></span><br><span class="line">        <span class="comment">// fallback to use round robin</span></span><br><span class="line">        <span class="keyword">if</span> (maxTotalWeight &lt; <span class="number">0.001d</span>) &#123;</span><br><span class="line">            server =  <span class="built_in">super</span>.choose(getLoadBalancer(), key);</span><br><span class="line">            <span class="keyword">if</span>(server == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> server;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// generate a random weight between 0 (inclusive) to maxTotalWeight (exclusive)</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">randomWeight</span> <span class="operator">=</span> random.nextDouble() * maxTotalWeight;</span><br><span class="line">            <span class="comment">// pick the server index based on the randomIndex</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Double d : currentWeights) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d &gt;= randomWeight) &#123;</span><br><span class="line">                    serverIndex = n;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            server = allList.get(serverIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Transient. */</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> (server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Next.</span></span><br><span class="line">        server = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在 <code>choose</code> 方法获取服务实例时，如果服务负载均衡器和所有访问器为空，则返回 null</li>
<li>之后当前所有服务的索引的最后一位，则是所有权重的总和，之后生成 <strong>0～总和</strong> 的随机权重</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Weight adjusting job started&quot;</span>);</span><br><span class="line">            <span class="type">AbstractLoadBalancer</span> <span class="variable">nlb</span> <span class="operator">=</span> (AbstractLoadBalancer) lb;</span><br><span class="line">            <span class="type">LoadBalancerStats</span> <span class="variable">stats</span> <span class="operator">=</span> nlb.getLoadBalancerStats();</span><br><span class="line">            <span class="keyword">if</span> (stats == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// no statistics, nothing to do</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">double</span> <span class="variable">totalResponseTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// find maximal 95% response time</span></span><br><span class="line">            <span class="keyword">for</span> (Server server : nlb.getAllServers()) &#123;</span><br><span class="line">                <span class="comment">// this will automatically load the stats if not in cache</span></span><br><span class="line">                <span class="type">ServerStats</span> <span class="variable">ss</span> <span class="operator">=</span> stats.getSingleServerStat(server);</span><br><span class="line">                totalResponseTime += ss.getResponseTimeAvg();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// weight for each server is (sum of responseTime of all servers - responseTime)</span></span><br><span class="line">            <span class="comment">// so that the longer the response time, the less the weight and the less likely to be chosen</span></span><br><span class="line">            <span class="type">Double</span> <span class="variable">weightSoFar</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// create new list and hot swap the reference</span></span><br><span class="line">            List&lt;Double&gt; finalWeights = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Double&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Server server : nlb.getAllServers()) &#123;</span><br><span class="line">                <span class="type">ServerStats</span> <span class="variable">ss</span> <span class="operator">=</span> stats.getSingleServerStat(server);</span><br><span class="line">                <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> totalResponseTime - ss.getResponseTimeAvg();</span><br><span class="line">                weightSoFar += weight;</span><br><span class="line">                finalWeights.add(weightSoFar);   </span><br><span class="line">            &#125;</span><br><span class="line">            setWeights(finalWeights);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Error calculating server weights&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            serverWeightAssignmentInProgress.set(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这其中作为最终要的角色则是 <code>DynamicServerWeightTask</code> 方法，主要通过 <code>totalResponseTime（总响应时间）</code> 来计算权重，其原理就是使用 <code>ServerStats</code> 在负载均衡器中捕获每个服务器的各种统计信息，那么总响应时间就是通过他的 <code>getResponseTimeAvg</code> 方法获取处理请求的平均总时间，以毫秒为单位，这个过程主要找到最大 95% 的响应时间</p>
<p>这样每个服务器的权重就是 所有服务器响应时间的总和减去响应时间 <code>（totalResponseTime - getResponseTimeAvg）</code> 这样得出的结果就是 <strong>响应时间越长则权重越小，则选中的几率就很小</strong></p>
<h4 id="随机策略（RandomRule）"><a href="#随机策略（RandomRule）" class="headerlink" title="随机策略（RandomRule）"></a>随机策略（RandomRule）</h4><p>RandomRule 主要是一个在现有服务器之间随机分配流量的负载均衡，他主要的步骤是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lb == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Server&gt; upList = lb.getReachableServers();</span><br><span class="line">            List&lt;Server&gt; allList = lb.getAllServers();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">serverCount</span> <span class="operator">=</span> allList.size();</span><br><span class="line">            <span class="keyword">if</span> (serverCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * No servers. End regardless of pass, because subsequent passes</span></span><br><span class="line"><span class="comment">                 * only get more restrictive.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> rand.nextInt(serverCount);</span><br><span class="line">            server = upList.get(index);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * The only time this should happen is if the server list were</span></span><br><span class="line"><span class="comment">                 * somehow trimmed. This is a transient condition. Retry after</span></span><br><span class="line"><span class="comment">                 * yielding.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server.isAlive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> (server);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Shouldn&#x27;t actually happen.. but must be transient or a bug.</span></span><br><span class="line">            server = <span class="literal">null</span>;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>通过<code>choose</code> 方法获取到服务器实例，如果负载均衡器和服务器为0则返回 <code>null</code></li>
<li>首先他会通过 <code>upList</code> 以及 <code>allList()</code> 分别获取存活服务器列表和所有服务器列表，之后通过 <code>Random</code> 来生成一个随机数生成器</li>
<li>如果服务器正常运行，则返回该服务，并对可以请求的服务器标注一个随机的值，这就让每次通过 <code>choose</code> 方法获取到的服务器实例都会有一个随机的标注。</li>
</ol>
<h4 id="客户端配置启用线性轮询策略（ClientConfigEnabledRoundRobinRule）"><a href="#客户端配置启用线性轮询策略（ClientConfigEnabledRoundRobinRule）" class="headerlink" title="客户端配置启用线性轮询策略（ClientConfigEnabledRoundRobinRule）"></a>客户端配置启用线性轮询策略（ClientConfigEnabledRoundRobinRule）</h4><p>客户端配置启用线性轮询策略，从名字上可以看出他就是为了启用 <code>RoundRobinRule</code> 策略的，因此他的整个流程都是通过 <code>RoundRobinRule</code> 来使用负载均衡器。而 <code>choose</code> 方法则也是通过 <code>RoundRobinRule</code> 来实现的，如果没有使用他则会出现 ：“This class has not been initialized with the RoundRobinRule class” 的报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientConfigEnabledRoundRobinRule</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalancerRule</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">RoundRobinRule</span> <span class="variable">roundRobinRule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoundRobinRule</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> &#123;</span><br><span class="line">        roundRobinRule = <span class="keyword">new</span> <span class="title class_">RoundRobinRule</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span> &#123;</span><br><span class="line">    	<span class="built_in">super</span>.setLoadBalancer(lb);</span><br><span class="line">    	roundRobinRule.setLoadBalancer(lb);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (roundRobinRule != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> roundRobinRule.choose(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;This class has not been initialized with the RoundRobinRule class&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最大空闲策略（BestAvailableRule）"><a href="#最大空闲策略（BestAvailableRule）" class="headerlink" title="最大空闲策略（BestAvailableRule）"></a>最大空闲策略（BestAvailableRule）</h4><p>该规则主要用于选择并发请求最少的服务器实例来提供服务，延伸自 <code>ClientConfigEnabledRoundRobinRule</code>，通过 <code>LoadBalancerStats</code> 来统计每个服务器的特征和信息，以此来过滤失败的服务实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (loadBalancerStats == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.choose(key);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Server&gt; serverList = getLoadBalancer().getAllServers();</span><br><span class="line">    <span class="type">int</span> <span class="variable">minimalConcurrentConnections</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">Server</span> <span class="variable">chosen</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Server server: serverList) &#123;</span><br><span class="line">        <span class="type">ServerStats</span> <span class="variable">serverStats</span> <span class="operator">=</span> loadBalancerStats.getSingleServerStat(server);</span><br><span class="line">        <span class="keyword">if</span> (!serverStats.isCircuitBreakerTripped(currentTime)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">concurrentConnections</span> <span class="operator">=</span> serverStats.getActiveRequestsCount(currentTime);</span><br><span class="line">            <span class="keyword">if</span> (concurrentConnections &lt; minimalConcurrentConnections) &#123;</span><br><span class="line">                minimalConcurrentConnections = concurrentConnections;</span><br><span class="line">                chosen = server;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (chosen == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.choose(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> chosen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>loadBalancerStats</code> 不为 null，则找出最小的并发连接数（minimalConcurrentConnections）来使用。假设 <code>loadBalancerStats</code> 为 null，则通过 <code>ClientConfigEnabledRoundRobinRule</code> 类中的 <code>choose</code> 类来使用线性轮询策略。</p>
<h4 id="过滤线性轮询策略（PredicateBasedRule）"><a href="#过滤线性轮询策略（PredicateBasedRule）" class="headerlink" title="过滤线性轮询策略（PredicateBasedRule）"></a>过滤线性轮询策略（PredicateBasedRule）</h4><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210629013902.png"></p>
<p>过滤线性轮询策略主要在过滤给定的服务器列表和负载均衡器后，通过内部定义的一个过滤器来筛选出服务实例清单，之后通过线性轮询方式过滤服务实例，并从清单选取一个服务实例。</p>
<blockquote>
<figure class="highlight plaintext"><figcaption><span>是服务器过滤逻辑的基本构建块，可用于规则和服务器列表过滤器。 谓词的输入对象是PredicateKey，里面有Server和负载均衡器的key信息。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">   public Server choose(Object key) &#123;</span><br><span class="line">       ILoadBalancer lb = getLoadBalancer();</span><br><span class="line">       Optional&lt;Server&gt; server = getPredicate().chooseRoundRobinAfterFiltering(lb.getAllServers(), key);</span><br><span class="line">       if (server.isPresent()) &#123;</span><br><span class="line">           return server.get();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="AbstractServerPredicate"><a href="#AbstractServerPredicate" class="headerlink" title="AbstractServerPredicate"></a>AbstractServerPredicate</h5><p>过滤线性轮询的主要功能主要通过 <code>AbstractServerPredicate</code> 进行实现，而 <code>AbstractServerPredicate</code> 是 <code>Predicate</code> 的实现。</p>
<blockquote>
<figure class="highlight plaintext"><figcaption><span>主要是用于确定给定输入的 true 或 false，因此也被称之为 “谓词”。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; 在数学逻辑中，谓词通常使用大写罗马字母表示，如P、Q、R这些，根据其变量值来可能为 “真假（true or false）” 的陈述。</span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt; 也可以理解为一个运算符或函数（布尔值函数），根据输入来返回一个 false or true。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 在初始阶段，他主要会通过 ```LoadBalancerStats``` 来获取负载均衡器的统计信息</span><br><span class="line">   1. 如果为空则返回负载均衡器的信息。</span><br><span class="line">   2. 不为空的话获取负载均衡器（```ILoadBalancer```），在获取负载均衡器的统计信息，并返回设置的负载均衡器统计信息（```setLoadBalancerStats```）。</span><br><span class="line">       1. 如果未找到 LoadalancerStats 未找到则返回 null</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">   protected LoadBalancerStats getLBStats() &#123;</span><br><span class="line">       if (lbStats != null) &#123;</span><br><span class="line">           return lbStats;</span><br><span class="line">       &#125; else if (rule != null) &#123;</span><br><span class="line">           ILoadBalancer lb = rule.getLoadBalancer();</span><br><span class="line">           if (lb instanceof AbstractLoadBalancer) &#123;</span><br><span class="line">               LoadBalancerStats stats =  ((AbstractLoadBalancer) lb).getLoadBalancerStats();</span><br><span class="line">               setLoadBalancerStats(stats);</span><br><span class="line">               return stats;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="2">
<li>之后通过 <code>getServerOnlyPredicate</code> 来获取布尔值函数（即谓词），并通过 <code>getEligibleServers</code> 筛选出合格的服务器。最后使用 <code>chooseRandomlyAfterFiltering</code> 方法筛选并随机选择服务器实例，最后也可以通过 <code>chooseRoundRobinAfterFiltering</code> 方法来创建循环选择过筛选后的服务器实例。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;Server&gt; <span class="title function_">chooseRandomlyAfterFiltering</span><span class="params">(List&lt;Server&gt; servers)</span> &#123;</span><br><span class="line">    List&lt;Server&gt; eligible = getEligibleServers(servers);</span><br><span class="line">    <span class="keyword">if</span> (eligible.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.absent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(eligible.get(random.nextInt(eligible.size())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Choose a server in a round robin fashion after the predicate filters a list of servers. Load balancer key </span></span><br><span class="line"><span class="comment"> * is presumed to be null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;Server&gt; <span class="title function_">chooseRoundRobinAfterFiltering</span><span class="params">(List&lt;Server&gt; servers)</span> &#123;</span><br><span class="line">    List&lt;Server&gt; eligible = getEligibleServers(servers);</span><br><span class="line">    <span class="keyword">if</span> (eligible.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.absent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(eligible.get(nextIndex.getAndIncrement() % eligible.size()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Choose a random server after the predicate filters list of servers given list of servers and</span></span><br><span class="line"><span class="comment"> * load balancer key. </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;Server&gt; <span class="title function_">chooseRandomlyAfterFiltering</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> &#123;</span><br><span class="line">    List&lt;Server&gt; eligible = getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">    <span class="keyword">if</span> (eligible.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.absent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(eligible.get(random.nextInt(eligible.size())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Choose a server in a round robin fashion after the predicate filters a given list of servers and load balancer key. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;Server&gt; <span class="title function_">chooseRoundRobinAfterFiltering</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> &#123;</span><br><span class="line">    List&lt;Server&gt; eligible = getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">    <span class="keyword">if</span> (eligible.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.absent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(eligible.get(nextIndex.getAndIncrement() % eligible.size()));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AbstractServerPredicate <span class="title function_">ofKeyPredicate</span><span class="params">(<span class="keyword">final</span> Predicate&lt;PredicateKey&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AbstractServerPredicate</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@edu</span>.umd.cs.findbugs.annotations.SuppressWarnings(value = <span class="string">&quot;NP&quot;</span>)</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(PredicateKey input)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p.apply(input);</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create an instance from a predicate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AbstractServerPredicate <span class="title function_">ofServerPredicate</span><span class="params">(<span class="keyword">final</span> Predicate&lt;Server&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AbstractServerPredicate</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@edu</span>.umd.cs.findbugs.annotations.SuppressWarnings(value = <span class="string">&quot;NP&quot;</span>)</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(PredicateKey input)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p.apply(input.getServer());</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="区域感知轮询策略（ZoneAvoidanceRule）"><a href="#区域感知轮询策略（ZoneAvoidanceRule）" class="headerlink" title="区域感知轮询策略（ZoneAvoidanceRule）"></a>区域感知轮询策略（ZoneAvoidanceRule）</h5><p>该策略是 <strong>过滤线性轮询策略（PredicateBasedRule）</strong> 的实现类，主要以 <strong>区域和可用性过滤服务器的规则</strong> 为基础，也通过组合过滤条件和该策略本身的过滤条件相辅相成，而 AbstractServerPredicate 则为次过滤条件。</p>
<p>他的过滤条件也非常的简单，首先，需要通过 <code>randomChooseZone</code> 来随机选择服务器，之后 <code>selectedZone</code> 来选择区域并返回，之后 <code>totalServerCount</code> 统计服务器总数，以及获取实例数（<code>getInstanceCount</code>）。</p>
<p>在配合 <code>index</code> 和 <code>sum</code>，其中 index 及服务器总数，每发现一个 +1。而 <code>sum</code> 则是实例数的总和，当服务总数小于总和时，那么将会选择该区域并返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String <span class="title function_">randomChooseZone</span><span class="params">(Map&lt;String, ZoneSnapshot&gt; snapshot,</span></span><br><span class="line"><span class="params">        Set&lt;String&gt; chooseFrom)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (chooseFrom == <span class="literal">null</span> || chooseFrom.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">selectedZone</span> <span class="operator">=</span> chooseFrom.iterator().next();</span><br><span class="line">    <span class="keyword">if</span> (chooseFrom.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> selectedZone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalServerCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String zone : chooseFrom) &#123;</span><br><span class="line">        totalServerCount += snapshot.get(zone).getInstanceCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> random.nextInt(totalServerCount) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String zone : chooseFrom) &#123;</span><br><span class="line">        sum += snapshot.get(zone).getInstanceCount();</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= sum) &#123;</span><br><span class="line">            selectedZone = zone;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> selectedZone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当选择完后，就是通过 <code>availableZones</code> 方法获取可用区域，如果可用区数量等于1，则返回可用区（<code>availableZones</code>），当实例数为0时，开始移出可用区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (availableZones.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> availableZones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移出可用区的方式有很多，其中就是 <strong>获取心跳次数除于实例总数大于等于服务无回应百分比或每台服务器负载</strong>，小于0的，也会被移出可用区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((<span class="type">double</span>) zoneSnapshot.getCircuitTrippedCount())</span><br><span class="line">                        / instanceCount &gt;= triggeringBlackoutPercentage</span><br><span class="line">                        || loadPerServer &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    availableZones.remove(zone);</span><br><span class="line">                    limitedZoneAvailability = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>或者说每台服务器负载（<code>loadPerServer</code>）减去每台服务器最大负载（<code>maxLoadPerServer</code>）小于 0.000001d，则会被添加至最差区域（<code>worstZones</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Math.abs(loadPerServer - maxLoadPerServer) &lt; <span class="number">0.000001d</span>) &#123;</span><br><span class="line">    <span class="comment">// they are the same considering double calculation</span></span><br><span class="line">    <span class="comment">// round error</span></span><br><span class="line">    worstZones.add(zone);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (loadPerServer &gt; maxLoadPerServer) &#123;</span><br><span class="line">    maxLoadPerServer = loadPerServer;</span><br><span class="line">    worstZones.clear();</span><br><span class="line">    worstZones.add(zone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过每台服务器负载（<code>loadPerServer</code>）大于服务器最大负载（<code>maxLoadPerServer</code>）的方式让其加入到最差区域中。</p>
<p>至于随机选择区（<code>randomChooseZon</code>），如果不为0，也会被移出可用区（因为避免区域被你霸占了），否则返回可用区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">String</span> <span class="variable">zoneToAvoid</span> <span class="operator">=</span> randomChooseZone(snapshot, worstZones);</span><br><span class="line">    <span class="keyword">if</span> (zoneToAvoid != <span class="literal">null</span>) &#123;</span><br><span class="line">        availableZones.remove(zoneToAvoid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> availableZones;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，当一系列的区域过滤完成后，通过线性轮询的方式从过滤结果中选出一个服务实例。</p>
<h4 id="可用性过滤策略（AvailabilityFilteringRule）"><a href="#可用性过滤策略（AvailabilityFilteringRule）" class="headerlink" title="可用性过滤策略（AvailabilityFilteringRule）"></a>可用性过滤策略（AvailabilityFilteringRule）</h4><p>该策略根据宕机或超过请求时限的活动连接来分配权重，他是 <code>PredicateBasedRule</code> 的延伸，其主要还是通过 <code>AbstractServerPredicate</code> 来实现具体的功能。</p>
<h3 id="Ribbon-负载均衡策略自定义"><a href="#Ribbon-负载均衡策略自定义" class="headerlink" title="Ribbon 负载均衡策略自定义"></a>Ribbon 负载均衡策略自定义</h3><p>自定义负载均衡策略需要先运行 <strong>consul</strong> 除服务消费者之外的集群，之后新建项目添加依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-netflix-ribbon&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.0.3&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/com.netflix.ribbon/ribbon-loadbalancer --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.netflix.ribbon&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;ribbon-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.7.18&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h4 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">Ribbon Rule</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">9003</span></span><br><span class="line"><span class="attr">spring.cloud.consul.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.service-name</span>=<span class="string">service-provider        # 服务提供者名字</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.register</span>=<span class="string">false                       # 是否注册服务</span></span><br></pre></td></tr></table></figure>

<h4 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h4><p>在启动类中通过 <code>@LoadBalancd</code> 以及 <code>@Bean</code> 来实例化 <code>restTemplate</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动类，通过 <span class="doctag">@LoadBalanced</span> 来开启客户端的负载均衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/06/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  实例化 RestTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> RestTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="RibbonConfig"><a href="#RibbonConfig" class="headerlink" title="RibbonConfig"></a>RibbonConfig</h4><p>在配置类中启用 <code>Configuration</code> 注解，并使用 <code>RibbonClient</code> 来配置服务提供者名称，最后通过 <code>Bean</code> 注解实例化负载均衡策略（RandomRule）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.IRule;</span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.RandomRule;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.ribbon.RibbonClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.ribbon.RibbonClientConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置类，通过 <span class="doctag">@RibbonClient</span> 注解来配置服务名以及实例化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/06/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RibbonClient(name = &quot;service-provider&quot;, configuration = RibbonClientConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RibbonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化 Ribbon 的随机策略（RandomRule）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> RandomRule</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IRule <span class="title function_">irule</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TestController"><a href="#TestController" class="headerlink" title="TestController"></a>TestController</h4><p>测试类主要用于通过负载均衡器来使用负载均衡策略实现选择服务实例的效果：</p>
<blockquote>
<p>运行后浏览器打开 <a target="_blank" rel="noopener" href="http://localhost:9003/hey">http://localhost:9003/hey</a> 每次刷新会得到不同的服务提供者实例返回的信息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalancerClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hey&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServiceInstance</span> <span class="variable">serviceInstance</span> <span class="operator">=</span> loadBalancerClient.choose(<span class="string">&quot;service-provider&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">callService</span> <span class="operator">=</span> <span class="string">&quot;Host: &quot;</span> + serviceInstance.getHost() + <span class="string">&quot; Port: &quot;</span> + serviceInstance.getPort() + <span class="string">&quot; Date:&quot;</span> + simpleDateFormat.format(date);</span><br><span class="line">        <span class="keyword">return</span> callService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><p>需要注意的是 Feign <strong>是除了 RestTemplate 客户端实现服务发现外</strong> ，可以实现服务发现的另一种方式，通过整合 Ribbon 好后可以提供负载均衡的功能。</p>
<p>Feign 与 Ribbon 最为不同的就是调用方式，通常情况下 Ribbon 需要自己构建一个 HTTP 请求，然后 RestTemplate 将该请求发送给其他服务，<code>RibbonClient(value = &quot;serverName&quot;)</code> 就印证了这一点。</p>
<p>而 Feign 是在 Ribbon 的基础上在进行一层封装，因为是采用接口的方式他并不需要自己构建 HTTP 请求。<strong>只需要将其他服务方法定义成抽象方法即可</strong>，<code>@FeignClient(&quot;ServerName&quot;)</code> 注解来调用服务。</p>
<blockquote>
<figure class="highlight plaintext"><figcaption><span>属性值应与服务中心方法名一致</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### Feign 工作流程</span><br><span class="line">上述这些与 Feugn 的工作原理密不可分，在正常的情况下他有四个步骤，分别为：</span><br><span class="line">![](https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210701034924.png)</span><br><span class="line"></span><br><span class="line">在这个过程中，如果使用了 ```@FeignClient``` 注解，那么 Feign 客户端将会创建一个动态代理。</span><br><span class="line">之后调用这个接口（即调用了 Feign 客户端所创建的动态代理），而 Feign 客户端的动态代理会根据接口上的 ```@RequestMapping``` 注解来构造出地址以及方法。</span><br><span class="line">最后发起请求并解析响应</span><br><span class="line"></span><br><span class="line">![](https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210701030423.png)</span><br><span class="line"></span><br><span class="line">服务提供者 **调用了** 定义 ```@FeignClient``` 注解的接口时，Feign 会构建一个动态代理，之后构造地址</span><br><span class="line">最终向接口发送请求（也就是服务提供者）</span><br><span class="line"></span><br><span class="line">#### Feign 负载均衡</span><br><span class="line">![](https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210701111804.gif)</span><br><span class="line">Feign 是一个声明式的 Web Servce 客户端，Spring cloud 客户端添加了Spring MVC 的支持，Feign 在整合了 Ribbon 后即可一共负载均衡的功能，在此之前我们需要添加依赖：</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>以及在 <code>application.properties</code> 全局配置文件中配置服务端口以及名称等：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">Feign Configuration</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8780</span></span><br><span class="line"><span class="attr">spring.cloud.consul.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.register</span>=<span class="string">false     </span></span><br></pre></td></tr></table></figure>

<p>然后在启动类中通过 <code>EnableDiscoveryClient</code> 来启用服务发现，并使用 <code>@EnableFeignClients</code> 注解来启动 Feign 客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动类，通过 <span class="doctag">@EnableDiscoveryClient</span> 实现服务中心，以及 <span class="doctag">@EnableFeignClients</span> 来支持 Feign</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h5><p>在配置类中我们主要用于实现使用默认契约，即 <code>Spring cloud Netfilx MVC Controller</code> 改为 <code>feign.Contract.Defaull</code> 原生契约。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feign.Contract;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义 Feign 配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 Spring cloud MVC Netfilx Controller 改为 feign.Contract.Defaull</span></span><br><span class="line"><span class="comment">     * 之后契约将默认改为 Feign 原生契约，之后可以使用默认注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> feign.Contract.Defaull</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Contract <span class="title function_">contract</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Contract</span>.Default();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h5><p>为了通过 consul 服务发现提供者，因此需要通过 <code>FeignClient</code> 注解来进行连接，也就是 Feign 工作流程中的 “构造地址‘，以及 Feign 的配置等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feign.RequestLine;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.config.FeignConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FeignClient 接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FeignClient(contextId = &quot;feignClient&quot;, name = &quot;service-provider&quot;, configuration = FeignConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FeignClientInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 <span class="doctag">@RequestLine</span> 将 Spring MVC 注解修改为原生的 <span class="doctag">@RequestLine</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> <span class="doctag">@RequestLine</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestLine(&quot;GET /hey&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hey</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h5><p>最后的 Feign 控制器则是为了提供服务，因此只需要通过调用 Feigin 接口即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.FeignClientInterface;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用接口以此来提供服务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    FeignClientInterface feignClientInterface;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hey&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> feignClientInterface.hey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Feign-记录日志"><a href="#Feign-记录日志" class="headerlink" title="Feign 记录日志"></a>Feign 记录日志</h4><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210701155448.png"></p>
<p>在 Feign 中，记录日志的等级可以分为四个，分别为：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>DA</th>
</tr>
</thead>
<tbody><tr>
<td>NONE</td>
<td>不记录（默认）</td>
</tr>
<tr>
<td>BASIC</td>
<td>只记录和请求方法、URL、相应状态码以及执行时间</td>
</tr>
<tr>
<td>HEADERS</td>
<td>只记录基本信息，请求和响应的标题</td>
</tr>
<tr>
<td>FULL</td>
<td>记录请求、响应的标题以及正文和元数据</td>
</tr>
</tbody></table>
<p>在 Feigin 负载均衡的基础上，我们实际上只需要修改或添加 <code>config</code> 包下的 <code>FeignConfig</code> 类即可：</p>
<h5 id="FeignConfig"><a href="#FeignConfig" class="headerlink" title="FeignConfig"></a>FeignConfig</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feign.Contract;</span><br><span class="line"><span class="keyword">import</span> feign.Logger;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义 Feign 配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 Spring cloud MVC Controller 改为 feign.Contract.Defaull</span></span><br><span class="line"><span class="comment">     * 之后契约将默认改为 Feign 原生契约，之后可以使用默认注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> feign.Contract.Defaull</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Contract <span class="title function_">contract</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Contract</span>.Default();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志管理器记录等级为 FULL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Logger.Level.Full</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.Level <span class="title function_">level</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Logger 是一个日志管理器，与 level 组合为 <code>Logger.Level</code> 即日志管理器等级</p>
</blockquote>
<h5 id="application-properties-1"><a href="#application-properties-1" class="headerlink" title="application.properties"></a>application.properties</h5><p>之后在 <code>applicatin.properties</code> 全局配置文件中添加 <code>logging.level.com.example.demo=DEBUG</code> 来开启记录日志的包：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">Feign Configuration</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8780</span></span><br><span class="line"><span class="attr">spring.cloud.consul.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.register</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">logging.level.com.example.demo</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>
	

	
		<span class="different-posts"><a href="/2022/04/21/java/spring%20cloud/7.Spring%20cloud%20Ribbon%20or%20RestTemplate%20and%20Feign/" onclick="window.history.go(-1); return false;">⬅️ Go back </a></span>

	

</article>

	</main>

	<footer class="footer">
	<div class="footer-content">
		
	      <div class="footer__element">
	<p>欢迎来到我的 blog <br><br> 通过 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>+<a target="_blank" rel="noopener" href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a> 进行构建的，存放在 <a target="_blank" rel="noopener" href="https://github.com/vendanges/vendanges.github.io">Github</a> 上。</p>
</div>

	    
	      <div class="footer__element">
	<h5>Check out</h5>
	<ul class="footer-links">
		<li class="footer-links__link"><a href="/archives">Archive</a></li>
		
		  <li class="footer-links__link"><a href="/atom.xml">RSS</a></li>
	    
		<li class="footer-links__link"><a href="/about">about page</a></li>
		<li class="footer-links__link"><a href="/tags">Tags</a></li>
		<li class="footer-links__link"><a href="/categories">Categories</a></li>
	</ul>
</div>

	    

		<div class="footer-credit">
			<span>© 2022 John Doe | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a></span>
		</div>

	</div>


</footer>



</body>

</html>
