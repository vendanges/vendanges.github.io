<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="theme-color" content="#33474d">
	<title>琼瑶</title>
	<link rel="stylesheet" href="/css/style.css" />
	
      <link rel="alternate" href="/atom.xml" title="琼瑶" type="application/atom+xml">
    
<meta name="generator" content="Hexo 6.1.0"></head>

<body>

	<header class="header">
		<nav class="header__nav">
			
				<a href="/" class="header__link" style="color: #fff">Home</a>
			
				<a href="/archives" class="header__link" style="color: #fff">Archive</a>
			
				<a href="/about" class="header__link" style="color: #fff">About</a>
			
		</nav>
		<!-- <h1 class="header__title"><a href="/">琼瑶</a></h1> -->
		<h1 class="header__title"><a href="/"><img style="width: 290px;" src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/202204152017786.png"></a></h1>
		<h2 class="header__subtitle">梦入琼楼寒有月，行过石树冻无烟</h2>
	</header>

	<main>
		
	<span class="different-posts different-posts_earlier">📖 <a href="/page/13">earlier posts</a> 📖</span>




	<article>
	
		<h1><a href="/2022/04/21/java/spring cloud/8.Spring cloud Hystrix 容错处理/">Spring cloud Hystrix 容错处理</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2022-04-21</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-none-link" href="/tags/java/" rel="tag">java</a> <a class="article__tag-none-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a>
			</span>
		
	</div>

	

	
		<p>Hystrix 是由 Netflix 开源的一个延迟和容错库，旨在隔离对远程系统、服务和第三方库的访问点，他主要通过：“隔离、降级、融断、缓存”，等方式来避免或解决雪崩效应。处理和预防这类问题的项目也很多，通常主流的是 Sentinel、Hystrix、Resillience4j 三类解决方案。</p>
<blockquote>
<p>Sentinel</p>
<blockquote>
<p>阿里巴巴于 2012年 发布的面向分布式服务架构的轻量级流量控制组件。</p>
</blockquote>
<p>Resilience4j </p>
<blockquote>
<p>他是一个受 Netfilx Hystrix 启发的轻量级容错库，专门为函数式编程而设计</p>
</blockquote>
</blockquote>
<h2 id="雪崩效应"><a href="#雪崩效应" class="headerlink" title="雪崩效应"></a>雪崩效应</h2><p>雪崩效应也被称之为 “服务雪崩”，而雪崩效应的造成就是 <strong>级联</strong> 的崩溃，假设服务A调用服务B，服务B调用服务C，服务C调用服务D，这其中任何一个节点无法使用，就会造成下面的服务无法使用，这就会产生级联故障。</p>
<p>如果这种请求很多，那么将会导致不可用的服务越来越多，之后占用的计算机资源也越多，而这些请求则会消耗系统资源，导致其他请求也不可用，这种现象也被称之为：“服务雪崩”。</p>
<blockquote>
<p>也就是说当服务提供者导致了服务消费者不可使用，并将问题逐渐放大至微服务系统，进而造成系统崩溃。</p>
</blockquote>
<h3 id="造成雪崩原因"><a href="#造成雪崩原因" class="headerlink" title="造成雪崩原因"></a>造成雪崩原因</h3><p>雪崩效应的造成原因可以是流量激增、硬件故障、bug、缓存、资源耗尽、线程同步等待、配套资源不可用等：</p>
<h4 id="流量激增"><a href="#流量激增" class="headerlink" title="流量激增"></a>流量激增</h4><p>在目前，造成流量激增的方式可以恶意攻击，或者说是爬虫造成的都有可能，这种主要体现在了京东 6·18 活动中。</p>
<h4 id="硬件故障"><a href="#硬件故障" class="headerlink" title="硬件故障"></a>硬件故障</h4><p>假设一个集群中，有两个服务提供者，一个服务提供者的硬件损害。那么整个集群就成为了单点应用，导致服务的压力加大，从而出现了服务延迟，由于服务延迟的不断增加，最终导致了雪崩。</p>
<h4 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h4><p>通常程序中出现 bug 都是正常的事情，在 spring cloud 中，假设有一个不应该被类使用的接口被调用，则会造成服务之间的互相调用导致的循环逻辑问题，则会可能导致服务雪崩。</p>
<h4 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h4><p>缓存问题主要可以分为缓存穿透、缓存击穿、缓存雪崩等三个问题：</p>
<h5 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h5><p>缓存穿透指的是用户不断请求数据库中没有的数据，这将会导致数据库的压力过大。至于这种问题的防范问题，可以通过下述方法解决：</p>
<ol>
<li>在路由中增加权限校验</li>
<li>设置最大（max）与最小（min）的拦截请求（大于等于或小于等于）</li>
</ol>
<h5 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h5><p>缓存击穿是指 <strong>缓存没有数据，但数据库中有数据（通常是缓存时间到期了）</strong>，当用户在缓存中没有得到数据，就从数据库中获得数据，从而让数据库压力增大，就会造成缓存击穿。</p>
<blockquote>
<p>至于预防缓存击穿，那么就就是将 <strong>热点数据</strong> 设置为永不过期，来解决问题。</p>
</blockquote>
<h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><p>缓存雪崩说直白一点，就是缓存大量过期，而此时很多用户都是查询缓存中的数据，从而将流量转向数据库，进一步导致数据库宕机。预防这种问题需要通过将缓存数据的过期时间为 <strong>随机，以此来防止数据缓存同一时间大量过期。</strong> 如果将缓存击穿的问题解决了，那么缓存雪崩的问题也可以适当的预防。</p>
<h4 id="资源耗尽"><a href="#资源耗尽" class="headerlink" title="资源耗尽"></a>资源耗尽</h4><p>资源耗尽主要由两种原因造成的原因可以是：“服务提供者不可用，导致服务消费者等待，进而造成资源消耗”，也可是用户的大量流量请求，以及重试流量加大导致的。</p>
<h4 id="线程同步等待"><a href="#线程同步等待" class="headerlink" title="线程同步等待"></a>线程同步等待</h4><p>假设系统采用的是服务调用模式，<strong>核心服务和非核心服务共用一个线程池以及消息队列，假设一个核心的业务线程调用了一个非核心进程</strong>，那么这个非核心进程一旦出现问题，则导致核心线程出现问题。如果核心线程断了，那么将会导致后续的线程也一一崩溃，最终导致雪崩。</p>
<h4 id="配套资源不可用"><a href="#配套资源不可用" class="headerlink" title="配套资源不可用"></a>配套资源不可用</h4><p>配套资源不可用可能是数据中心不可用或者电信基础网络服务出现问题，欣慰的是这类事故出现的概率极低。</p>
<h3 id="Hystrix-的解决方式"><a href="#Hystrix-的解决方式" class="headerlink" title="Hystrix 的解决方式"></a>Hystrix 的解决方式</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210704165337.png"></p>
<h4 id="熔断机制"><a href="#熔断机制" class="headerlink" title="熔断机制"></a>熔断机制</h4><p>至于 Hystrix 熔断机制，他主要通过融断器来执行融断的工作，熔断器在现实生活中的运用主要是 “保险丝”。</p>
<blockquote>
<p>保险丝（fuse）的在电器的主要作用就是 <strong>当电器的电流异常升高到一定热度的时候，那么保险丝自身熔断来切断电流，以此来保护电路的安全运行</strong></p>
</blockquote>
<h5 id="快速失败及熔断机制"><a href="#快速失败及熔断机制" class="headerlink" title="快速失败及熔断机制"></a>快速失败及熔断机制</h5><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210704165348.png"><br>Hystrix 的熔断器可以实现快速失败，所谓快速失败就是当一个问题达到了某个规则的阀值，则该请求以后调用任何接口都会失败，最后导致不会访问远程服务器，以此来防止应用程序和资源的消耗。</p>
<p>熔断器能够诊断错误是否经过修正，如果已经修正那么熔断器则会关闭，让应用程序在此调用操作。熔断器能够记录最近调用所发生的错误次数，假设熔断器小于阀值，则可以关闭，否则继续开启。</p>
<p>熔断在正常状态下，一般处于关闭状态，如果调用的服务出错值达到莫个阀值，则会让其快速失效，以此来避免大量的无效请求影响系统。</p>
<p>一段时间过后熔断机制将会进入半尝试状态，允许少量请求进行尝试，如果成功则关闭熔断状态，否则将继续持续。</p>
<h4 id="隔离机制"><a href="#隔离机制" class="headerlink" title="隔离机制"></a>隔离机制</h4><p>隔离机制主要分为线程池隔离以及信号量隔离模式，在病毒传播中为了防止病毒扩散，最好的方式就是隔离病毒携带者，从而来保护正常的个体。这种方式在分布式系统中也采用隔离的方式进行容错处理。</p>
<h5 id="线程池隔离模式"><a href="#线程池隔离模式" class="headerlink" title="线程池隔离模式"></a>线程池隔离模式</h5><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210704224421.png"><br>在 Hystrix 的线程池隔离模式下，会为每一个 <strong>依赖建立一个线程池，以此来存储当前的依赖请求，线程池对请求进行处理。</strong> 线程池的主要作用就是隔离线程的依赖，以此来限制线程的并发访问和阻塞扩张。</p>
<p><strong>当流量达到峰值的时候</strong>，如果不能及时处理的请求将会被存储到线程池后进行处理。<strong>运营环境被隔离时</strong>，会根据依赖划分多个线程池，以此来进行资源隔离，就算调用的服务代码存在 bug，也不会对系统的其他服务造成影响。</p>
<h5 id="信号量隔离模式"><a href="#信号量隔离模式" class="headerlink" title="信号量隔离模式"></a>信号量隔离模式</h5><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210704224435.png"><br>信号量隔离模式主要用于记录当前请求的数量，他内在存在了一个类似 <strong>“规则”</strong> 的，当信号量小于等于规则内最大的数量时，将会丢弃请求，否则将会执行请求，且对当前的信号量加一。</p>
<h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><p>服务降级的主要机制就是 <strong>如果一个资源快不够了，则需要将某些服务先关掉，之后等到资源足够时在进行开启</strong>，和熔断的目的相差无几，以此来保证上游服务的稳定性。根据业务的不同，降级也分为两种模式，分别为：</p>
<h5 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h5><p>Fallback 一词也被称之为 “倒退” 的意思，及如果服务失败，那么则会通过 fallback 的方式进行降级。</p>
<h5 id="服务级联模式"><a href="#服务级联模式" class="headerlink" title="服务级联模式"></a>服务级联模式</h5><p>服务级联模式则是如果服务失败，则需要调用备用服务，服务级联模式会尽可能的返回数据。</p>
<blockquote>
<p>这样的做法如果考虑不充分会造成级联的崩溃，假设在缓存失败后将全部流量导到数据库请求中，那么数据库可能会直接崩溃，因此级联模式也考验开发者的能力</p>
</blockquote>
<p>简单来讲服务降级的两种方式分别是分级，将故障的服务丢弃，而服务级联模式则是将请求转移在另一个集群上。</p>
<h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>缓存机制就是将请求的所有结果进行缓存，如果有相同的请求发送过来，则直接从缓存中取出结果，以此来减少请求的开销。</p>
<h3 id="Hystrix-Fallback-实现"><a href="#Hystrix-Fallback-实现" class="headerlink" title="Hystrix Fallback 实现"></a>Hystrix Fallback 实现</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210705222024.png"><br>通常回退方法的实现有两种，一种是通过 <code>feign</code> 来进行实现，另一种解决方案则是根据 <code>@HystrixCommand</code> 注解进行实现，在此之前我们需要添加依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-hystrix --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>之后在启动类中添加注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动类，分别开启 consul、feign 以及服务熔断</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>尽管 <code>@EnableCircuitBreaker</code> 在 <strong>3.0.1</strong> 开始 Hystrix 就不在 <code>Spring cloud Netfilx</code> 中了，但是他是唯一一个实现断路器的注解</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://martinfowler.com/bliki/CircuitBreaker.html">https://martinfowler.com/bliki/CircuitBreaker.html</a></p>
</blockquote>
</blockquote>
<h4 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">Hystrix</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">9900</span></span><br><span class="line"><span class="attr">spring.cloud.consul.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.service-name</span>=<span class="string">service-provider</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.register</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">feign.hystrix.enabled</span>=<span class="string">true                                    # 开启 Hystrix</span></span><br></pre></td></tr></table></figure>


<h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使 Feign 支持 Hystrix，即添加 fallback 处理类，在服务熔断时返回 fallback 类中内容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;service-provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFeignFallbackClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加指定的 fallback 类，在服务熔断时返回 fallback 类内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hey&quot;)</span></span><br><span class="line">    String <span class="title function_">hey</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.service.MyFeignFallbackClient;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用 FeiginFallback 客户端</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyFeignFallbackClient myFeignFallbackClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hey&quot;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;defaultCities&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fallback</span> <span class="operator">=</span> myFeignFallbackClient.hey();</span><br><span class="line">        <span class="keyword">return</span> fallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">defaultCities</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;No server!!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hystrix-Dashboard-consul"><a href="#Hystrix-Dashboard-consul" class="headerlink" title="Hystrix Dashboard (consul)"></a>Hystrix Dashboard (consul)</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210706113456.png"><br>Hystrix Dashboard 即 “Hystrix 仪表盘”，也是除了容错之外还提供的实时监控功能，他会实时的累加记录所有关于 <strong>HystrixCommand</strong> 执行的信息，其中包含了每秒执行了多少请求，以及成功或失败等信息。</p>
<blockquote>
<p>Hystrix Dashboard 是一款针对 Hystrix 进行实时监控的工具，可以实现出实时监控数据，并直观的显示 Hystrix Command 的请求响应时间、请求成功率等</p>
</blockquote>
<p>因为 Hystrix Dashboard 仅仅实现了数据的监控，因此 <strong>我们需要在 Hystrix Fallback 的基础上进行扩展</strong>，其中启动类需要修改并添加依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-hystrix --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-hystrix-dashboard --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.7.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启用服务发现以及 feign、Hystrix Dashboard 和服务熔断等注解支持，并配置 Servlet</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletRegistrationBean <span class="title function_">servletRegistrantionBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HystrixMetricsStreamServlet</span> <span class="variable">hystrixMetricsStreamServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HystrixMetricsStreamServlet</span>();</span><br><span class="line">        <span class="type">ServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>(hystrixMetricsStreamServlet);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registrationBean.addUrlMappings(<span class="string">&quot;/actuator/hystrix.stream&quot;</span>);</span><br><span class="line">        registrationBean.setName(<span class="string">&quot;HystrixMetricsStreamServlet&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="application-properties-1"><a href="#application-properties-1" class="headerlink" title="application.properties"></a>application.properties</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">HystrixDashboard</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">9502</span></span><br><span class="line"><span class="attr">spring.cloud.consul.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.service-name</span>=<span class="string">service-provider</span></span><br><span class="line"><span class="attr">feign.hystrix.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">hystrix.dashboard.proxy-stream-allow-list</span>=<span class="string">*        # 设置仪表板代理流允许列表为所有</span></span><br></pre></td></tr></table></figure>

<p>当一切完成之后访问 <a target="_blank" rel="noopener" href="http://localhost:9502/hystrix">http://localhost:9502/hystrix</a> 并在输入框输入 <a target="_blank" rel="noopener" href="http://localhost:9502/actuator/hystrix.stream">http://localhost:9502/actuator/hystrix.stream</a> 即可。</p>
<blockquote>
<p>Hystrix Turbine 与 Hystrix Dashboard 的区别就是一个只能看到单个应用程序内的服务信息，而另一个则是多个实例集群的状态形式展现，因此 Hystrix Turbine 由此而生。</p>
<blockquote>
<p><strong>强烈建议使用 Eureka</strong></p>
</blockquote>
</blockquote>

	

	

</article>




	<article>
	
		<h1><a href="/2022/04/21/java/spring cloud/7.Spring cloud Ribbon or RestTemplate and Feign/">Spring cloud Ribbon or RestTemplate and Feign</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2022-04-21</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-none-link" href="/tags/java/" rel="tag">java</a> <a class="article__tag-none-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a>
			</span>
		
	</div>

	

	
		<p>首先我们只需要知道在 Ribbon 和 Feign 或 RestTemplate 中，Ribbon 主要基于 HTTP和TCP出来进行客户端的负载均衡，他是由 Netfix 公司所开源项目 Netfix OSS 的一部分，可自动与 Netfix Server Discover 也就是 Eureka 进行交互。</p>
<blockquote>
<p>Ribbon 是不可以独立部署的，Spring cloud Ribbon 是基于 Ribbon 的实现。基于了轮廓、随机等规则自动调用服务，当然除此之外还可以根据自身需要来定义均衡算法。</p>
</blockquote>
<p>而 Feign 和 RestTemplate 都是用于实现服务发现， Feign 主要是声明试的 WebService 客户端，为我们提供了一个快捷、优雅的调用 HTTP API。后者则是需要服务的 IP地址等这些信息来实现各个服务之间的通信调用，区别就是 Feign 会 <strong>比 RestTemplate 简洁和优雅许多</strong>。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210621200441.png"><br>在仔细讲解 Ribbon 与 Feign 或 RestTemplate 之前，他们都是涉及或实现出负载均衡这个功能，因此负载均衡在这里尤为重要。</p>
<p>负载均额（Load Balance）从字面意思上我们可以理解为当一个数据请求时可以分摊多个单元进行分流，通常负载均衡会分为服务器端负载均衡以及客户端负载均衡两种。</p>
<h3 id="服务器端负载均衡"><a href="#服务器端负载均衡" class="headerlink" title="服务器端负载均衡"></a>服务器端负载均衡</h3><p>服务器端负载均衡主要是应对高并发和服务器端扩容的重要方法之一，负载均衡也通常讲的是服务器端负载均衡。服务器端的负载均衡主要通过在服务器与客户端之间添加负载均衡器进行实现，主要分为硬件和软件负载均衡，这里我们主要介绍软件的负载均衡。</p>
<blockquote>
<p> 无论是软件的负载均衡还是硬件的负载均衡均维护着一个正常服务清单，通过心跳机制来删除出现故障的服务节点，也可以通过他来恢复服务节点。</p>
</blockquote>
<p>软件负载均衡主要是在普通的服务器上安装具有负载均衡的软件来实现请求的分发，进而实现负载均衡，需要注意的是服务器端的 “正常服务提供者清单” 是存储在负载均衡器中的。</p>
<h3 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h3><p>客户端负载均衡与服务器端负载均衡相差无几，他们的区别主要是客户端他本身拥有 “正常服务提供者清单”，在客户端负载均衡中。所有客户端管理都管理着一份自己需要访问的服务提供者清单，而这些清单大多数从服务中心进行获取。</p>
<h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210622080816.png"><br>Ribbon 是 Netfix 公司所开源项目 Netfix OSS 的一部分，主要提供一个客户端负载均衡的云库。他主要基于 HTTP 和 TCP 的客户端负载均衡组件，之后的 Spring cloud Ribbon 是一个基于 Ribbon 实现，主要特点是可以根据需要自定义负载均衡算法。</p>
<blockquote>
<p>Choose Server 是负载均衡策略中 “线性轮询策略（Round Robin Ruie）” 工作流程内的第三步骤，其作用是获取服务列表中取服务进行请求，如果连续十次都没有获取到服务则报错。</p>
</blockquote>
<p>从上图中我们可以看到，Ribbon 本身所维护着 正常服务提供者清单的有效性，如果通过 <code>ChooseServer</code> 不可用，则会重新从服务中心获取有效的服务提供者清单来进行更新。</p>
<h3 id="Ribbon-接口类型"><a href="#Ribbon-接口类型" class="headerlink" title="Ribbon 接口类型"></a>Ribbon 接口类型</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210623161907.png"></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Type Info</th>
<th>Bean Name</th>
<th>Class Name</th>
</tr>
</thead>
<tbody><tr>
<td>IClientConfig</td>
<td><strong>用于读取配置</strong>，实现类是 <code>DefaultClientConfigIcmpl</code>，而默认值也是该类</td>
<td>ribbonClientConfig</td>
<td>DefaultClientConfigIcmpl</td>
</tr>
<tr>
<td>IRule</td>
<td><strong>负责处理负载均衡规则</strong>，实现类是 <code>ZoneAvoidanceRule</code> 默认通过他来选择实例，步骤是：</td>
<td>ribbonRule</td>
<td>ZoneAvoidanceRule</td>
</tr>
<tr>
<td></td>
<td>1.ServerList 获取所有可用的服务提供者列表</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>2.ServerListFileter 过滤一部分服务提供者地址</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>3.最后在剩下的地址中通过 IRule 选择一台服务器</td>
<td></td>
<td></td>
</tr>
<tr>
<td>IPing</td>
<td><strong>用来筛选掉无法访问的实例</strong></td>
<td>ribbonPing</td>
<td>DummyPing</td>
</tr>
<tr>
<td>ServerList <code>&lt;server&gt;</code></td>
<td><strong>用于获取服务提供者地址列表</strong>，可以是一组固定地址也可是服务中心中定期查询服务提供者的地址列表</td>
<td>ribbonServerList</td>
<td>ConfigurationBasedServerList</td>
</tr>
<tr>
<td>ServerListFileter <code>&lt;server&gt;</code></td>
<td>在原始服务提供者地址列表中，<strong>通过使用一定的策略过滤一部分不符合条件的地址</strong>（当动态使用 ServerList时使用）</td>
<td>ribbonServerListFilter</td>
<td>ZonePrefernenceServerListFilter</td>
</tr>
<tr>
<td>ILoadBalancer</td>
<td>可通过负载均衡中选择一个服务器，并通过标记暂停服务的服务器，一可以获取所有已知的服务器提供者列表</td>
<td>ribbonLoadBalancer</td>
<td>ZoneAwareLoadBalancer or BaseLoadBalancer</td>
</tr>
<tr>
<td>ServerListUpdater</td>
<td><strong>用于ServerList的更新</strong>，当服务中心的服务提供者发生变化的时候，ServerList 会根据 PollingServerListUpdater 来实现定时更新服务提供者列表</td>
<td>ribbonServerListUpdate</td>
<td>PollingServerListUpdater</td>
</tr>
</tbody></table>
<h3 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h3><p>负载均衡器很多都是通过 Ribbon 接口类型来进行实现具体的负载均衡 Bean 如：</p>
<p>| Bean | Type | Class Name |<br>| — | — | — | — |<br>| LoadBalancerClient | ILoad Balancer | RibbonLoadBalancerClient |<br>| AbstractLoadBalancer | ILoad Balancer | AbstractLoadBalancer |</p>
<h4 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h4><p>在初始化时 <code>execute()</code> 方法会通过ILoadBalancer 来从服务中心获取服务提供者地址列表，并每 10s 来检测一下服务的可用性。如果服务端可用性发生改变，或者数量不一致，那么 <code>RibbonLoadBanlancer</code> 会从注册中心更新服务提供者地址列表，之后可以根据 IRule 来进行负载均衡。</p>
<p>LoadBanlancer主要的职责是添加服务器、选择服务器、获取所有的服务器列表、获取可用的服务提供者列表等。</p>
<table>
<thead>
<tr>
<th>Method Name</th>
<th>Method Info</th>
</tr>
</thead>
<tbody><tr>
<td><code>addServers(List&lt;Server&gt; newServers)</code></td>
<td>向服务器初始列表中增加新的服务提供者地址列表</td>
</tr>
<tr>
<td><code>chooseServer(Object key)</code></td>
<td>从负载均衡器中选择一个服务器</td>
</tr>
<tr>
<td><code>markServerDown(Server server)</code></td>
<td>通知或标记已经暂停服务的服务器</td>
</tr>
<tr>
<td><code>getReachableServers()</code></td>
<td>返回获取到可用的服务提供者列表</td>
</tr>
<tr>
<td><code>getAllServers</code></td>
<td>获取所有看到服务提供者列表</td>
</tr>
</tbody></table>
<p>Load Balancer 主要用于定义软件负载均衡的操作接口，一个典型的负载负载均衡实现需要一组服务器进行。通常一个方法来标记特定的服务器不循环，一个调用将现有的服务器列表中选择一个服务器来进行提供服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  定义软件负载均衡的操作接口，一个典型的负载负载均衡实现需要一组服务器进行。通常一个方法来标记特定的服务器不循环</span></span><br><span class="line"><span class="comment"> * 一个调用将现有的服务器列表中选择一个服务器来进行提供服务。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stonse</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILoadBalancer</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 向服务器初始列表中增加新的服务提供者地址列表（host:port）</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> 添加新服务提供者</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addServers</span><span class="params">(List&lt;Server&gt; newServers)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从负载均衡器中选择一个服务器</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> 负载均衡器将可用于确定返回那个服务器的对象，如为空则</span></span><br><span class="line"><span class="comment">	 *         负载均衡器将不会使用此参数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 选择服务器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> Server <span class="title function_">chooseServer</span><span class="params">(Object key)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 由负载均衡器的客户端掉应来通知某个服务器暂停服务，否则 ILoadBalancer 依然认为他可以提供服务</span></span><br><span class="line"><span class="comment">	 * 直到下一次检测的周提</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> 标记已经暂停服务的服务器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markServerDown</span><span class="params">(Server server)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@deprecated</span>    getServerList 在 2016-01-20 就被弃用，取而代之的则是 getReachableServers 以及 getAllServer API。</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> 如果为 true 则只应用返回可用的服务器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Deprecated</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;Server&gt; <span class="title function_">getServerList</span><span class="params">(<span class="type">boolean</span> availableOnly)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回获取到可用的服务提供者列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Server&gt; <span class="title function_">getReachableServers</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取所有看到服务提供者列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;Server&gt; <span class="title function_">getAllServers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="AbstractLoadBalancer"><a href="#AbstractLoadBalancer" class="headerlink" title="AbstractLoadBalancer"></a>AbstractLoadBalancer</h4><p>Abstract Load Balancer 是 ILoad Balancer 的实现类，他包含了大多数负载均衡实现所需要的功能，典型的是 Load Balancer 的结构：</p>
<ol>
<li>基于特定的标准可以分时段的服务提供者信息列表</li>
<li>通过规则的定义和实现负载均衡的策略类</li>
<li>定义并实现一种机制来确定服务提供者表单中的节点、可用性的类。</li>
</ol>
<p>在这三类中，Abstract Load Balancer 类实现了服务提供者地址列表分组的作用，被 服务器组（ServerGroup） 来定义：</p>
<table>
<thead>
<tr>
<th>Method name</th>
<th>Method info</th>
</tr>
</thead>
<tbody><tr>
<td>ServerGroup</td>
<td></td>
</tr>
<tr>
<td></td>
<td>ALL：所有服务</td>
</tr>
<tr>
<td></td>
<td>STATUS_UP：正常运行的服务</td>
</tr>
<tr>
<td></td>
<td>STATUS_NOT_UP：下线或崩溃的服务</td>
</tr>
<tr>
<td>chooseServer</td>
<td></td>
</tr>
<tr>
<td></td>
<td>从负载均衡中选择一个服务器</td>
</tr>
<tr>
<td>getServerList(ServerGroup serverGroup)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>获取负载均衡中所有服务的实例列表</td>
</tr>
<tr>
<td>getLoadBalancerStats()</td>
<td></td>
</tr>
<tr>
<td></td>
<td>从 Load Balancer 来获取每个服务的所有细节统计信息</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractLoadBalancer contains features required for most loadbalancing</span></span><br><span class="line"><span class="comment"> * implementations.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * An anatomy of a typical LoadBalancer consists of 1. A List of Servers (nodes)</span></span><br><span class="line"><span class="comment"> * that are potentially bucketed based on a specific criteria. 2. A Class that</span></span><br><span class="line"><span class="comment"> * defines and implements a LoadBalacing Strategy via &lt;code&gt;IRule&lt;/code&gt; 3. A</span></span><br><span class="line"><span class="comment"> * Class that defines and implements a mechanism to determine the</span></span><br><span class="line"><span class="comment"> * suitability/availability of the nodes/servers in the List.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stonse</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractLoadBalancer</span> <span class="keyword">implements</span> <span class="title class_">ILoadBalancer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ServerGroup</span>&#123;</span><br><span class="line">        ALL,</span><br><span class="line">        STATUS_UP,</span><br><span class="line">        STATUS_NOT_UP        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * delegate to &#123;<span class="doctag">@link</span> #chooseServer(Object)&#125; with parameter null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">chooseServer</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> chooseServer(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * List of servers that this Loadbalancer knows about</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverGroup Servers grouped by status, e.g., &#123;<span class="doctag">@link</span> ServerGroup#STATUS_UP&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Server&gt; <span class="title function_">getServerList</span><span class="params">(ServerGroup serverGroup)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Obtain LoadBalancer related Statistics</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> LoadBalancerStats <span class="title function_">getLoadBalancerStats</span><span class="params">()</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="BaseLoadBalancer"><a href="#BaseLoadBalancer" class="headerlink" title="BaseLoadBalancer"></a>BaseLoadBalancer</h5><p>Base Load Balancer 类是 Abstract Load Balancer 的实现类或工具类，他可以用一个 List 集合（AllServerList）来保存所有服务实例，之后用另一个 List 保存（UpServerList）当前有效的服务实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Monitor(name = PREFIX + &quot;AllServerList&quot;, type = DataSourceType.INFORMATIONAL)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> List&lt;Server&gt; allServerList = Collections</span><br><span class="line">        .synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Server&gt;());</span><br><span class="line"><span class="meta">@Monitor(name = PREFIX + &quot;UpServerList&quot;, type = DataSourceType.INFORMATIONAL)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> List&lt;Server&gt; upServerList = Collections</span><br><span class="line">        .synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Server&gt;());</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Method name</th>
<th>Method info</th>
</tr>
</thead>
<tbody><tr>
<td>IpingStrategy</td>
<td>用于定义检查服务的策略，将 ping 所有的服务器（如果执行的很慢可能是你有大量的服务器在此集群中）</td>
</tr>
<tr>
<td>chooseServer</td>
<td>调用 rule 类中的 <code>choose</code> 方法来选择服务器对象（如果没有则返回 null）</td>
</tr>
<tr>
<td>PingTask()</td>
<td>每 x 秒运行一次定时器任务，检查服务器列表中每个服务器&#x2F;节点的状态（默认为 1000s）</td>
</tr>
<tr>
<td>markServerDown()</td>
<td>用于标注服务是否有效（mark Server Down called for server）</td>
</tr>
<tr>
<td>getReachableServer()</td>
<td>获取所有有效的服务实例列表</td>
</tr>
<tr>
<td>getAllServer()</td>
<td>拥有获取所有服务器实例列表</td>
</tr>
<tr>
<td>addServer()</td>
<td>向负载均衡器中添加一个新的服务实例列表</td>
</tr>
</tbody></table>
<p>除此之外，Base Load Balancer 类中的子类 <code>DynamicServerListLoadBalancer</code> 以及 <code>ZoneAwareLoadBalancer</code> 作为 <code>DynamicServerListLoadBalancer</code> 的子类，都实现了了一些能力，分别为：</p>
<p><strong>DynamicServerListLoadBalancer</strong><br>在负载均衡器的基础上做了进一步的扩展，可以在服务实例清单在运行时的动态更新的实现，以及还提供了一个过滤器标准来过滤掉不符合所需标准的服务器。</p>
<h3 id="Ribbon-Ping-的实现"><a href="#Ribbon-Ping-的实现" class="headerlink" title="Ribbon Ping 的实现"></a>Ribbon Ping 的实现</h3><p>在上述介绍中，我们都设计到了 Ping 或 “心跳” 这个概念，负载均衡中 Ping 机制主要用于检测服务提供者的有效性。<strong>他会每隔一段时间执行 Ping 来判断服务器是否存活</strong> ，而这些工作都将由 IPing 和他的实现类来负责（Ribbon 默认实现类是 DummyPing，但需要注意的是默认情况下不会激活 Ping 机制）。</p>
<table>
<thead>
<tr>
<th>Class Name</th>
<th>Class Info</th>
</tr>
</thead>
<tbody><tr>
<td>DummyPing</td>
<td>虚拟的 Ping 实现，当确定服务器活着的时候会返回 <code>true</code></td>
</tr>
<tr>
<td>NoOpPing</td>
<td>设么都不做直接返回 <code>true</code></td>
</tr>
<tr>
<td>PingConstant</td>
<td>IPing 的实现类，他用于返回任何设置的内容，true 或 false（通常只要常量参数为 true 为服务实例存活，否则为失效）</td>
</tr>
</tbody></table>
<h4 id="DummyPing"><a href="#DummyPing" class="headerlink" title="DummyPing"></a>DummyPing</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.client.config.IClientConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default simple implementation that marks the liveness of a Server</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stonse</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DummyPing</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalancerPing</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DummyPing</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">(Server server)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NoOpPing"><a href="#NoOpPing" class="headerlink" title="NoOpPing"></a>NoOpPing</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * No Op Ping</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stonse</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoOpPing</span> <span class="keyword">implements</span> <span class="title class_">IPing</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">(Server server)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PingConstant"><a href="#PingConstant" class="headerlink" title="PingConstant"></a>PingConstant</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netflix.loadbalancer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A utility Ping Implementation that returns whatever its been set to return</span></span><br><span class="line"><span class="comment"> * (alive or dead)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stonse</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PingConstant</span> <span class="keyword">implements</span> <span class="title class_">IPing</span> &#123;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">constant</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConstant</span><span class="params">(String constantStr)</span> &#123;</span><br><span class="line">				constant = (constantStr != <span class="literal">null</span>) &amp;&amp; (constantStr.toLowerCase().equals(<span class="string">&quot;true&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConstant</span><span class="params">(<span class="type">boolean</span> constant)</span> &#123;</span><br><span class="line">				<span class="built_in">this</span>.constant = constant;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getConstant</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> constant;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">(Server server)</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> constant;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p>AbstractLoadBalancerRule 是一个 <code>IRule</code> 的继承，他本身则是一个负载均衡策略的抽象类，而 IRule 主要定义了 <code>ILoadBalancer</code> ，其最为核心的方法为 <code>choose()</code>，这是用于选择服务器对象（服务实例），如过没有将会返回 null。</p>
<p>而定义 <code>IRule</code> 主要的目的第一就是为了辅助负载均衡器（<code>ILoadBalancer</code>）<strong>来通过负载均衡策略选择合适的服务实例</strong>，其默认使用的是 <strong>九大负载均衡</strong> 策略中的 <code>线性轮询策略（RoundRobinRule）</code>。</p>
<h4 id="线性轮询策略（Round-Robin-Rule）"><a href="#线性轮询策略（Round-Robin-Rule）" class="headerlink" title="线性轮询策略（Round Robin Rule）"></a>线性轮询策略（Round Robin Rule）</h4><p>由于 Round Robin Rule 是 ILoadBalancer 默认采用的负载均衡策略，因此也和他的流程非常符合，与此同时他还是作为著名的负载均衡策略，他主要定义了 <code>AVAILABLE_ONLY_SERVERS（仅可用服务器）</code>、<code>ALL_SERVERS（所有服务器）</code> 两个状态。</p>
<ol>
<li><code>choose(ILoadBalancer lb, Object key)</code> 方法从负载均衡中选择一个服务器并计数，<strong>如果没有则会返回</strong>：<code>“no load balancer”</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="literal">null</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;no load balancer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>incrementAndGetModulo</code> 方法会通过<code>serverCount</code> 函数来请求 <code>allServers（所有服务器）</code>，而 <code>incrementAndGetModulo</code> 方法则会获取下一个索引，也就是说 <strong>获取所有服务器，并从 0 的基础上 +1</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">incrementAndGetModulo</span><span class="params">(<span class="type">int</span> modulo)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> nextServerCyclicCounter.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> (current + <span class="number">1</span>) % modulo;</span><br><span class="line">        <span class="keyword">if</span> (nextServerCyclicCounter.compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最后通过 <code>choose(Object key)</code> 通过索引去服务列表获取服务，如果连续 <strong>10次没有获取到服务</strong>，则会返回: “No available alive servers after 10 tries from load balancer”。假设 <code>可达服务器（reachableServers）</code> 或 <code>服务器总数（allServers）</code> 为 0，则会输出: “No up servers available from load balancer” 错误。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (server == <span class="literal">null</span> &amp;&amp; count++ &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        List&lt;Server&gt; reachableServers = lb.getReachableServers();</span><br><span class="line">        List&lt;Server&gt; allServers = lb.getAllServers();</span><br><span class="line">        <span class="type">int</span> <span class="variable">upCount</span> <span class="operator">=</span> reachableServers.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">serverCount</span> <span class="operator">=</span> allServers.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((upCount == <span class="number">0</span>) || (serverCount == <span class="number">0</span>)) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;No up servers available from load balancer: &quot;</span> + lb);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextServerIndex</span> <span class="operator">=</span> incrementAndGetModulo(serverCount);</span><br><span class="line">        server = allServers.get(nextServerIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Transient. */</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;</span><br><span class="line">            <span class="keyword">return</span> (server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Next.</span></span><br><span class="line">        server = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;No available alive servers after 10 tries from load balancer: &quot;</span></span><br><span class="line">                + lb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重试策略（Retry-Rule）"><a href="#重试策略（Retry-Rule）" class="headerlink" title="重试策略（Retry Rule）"></a>重试策略（Retry Rule）</h4><p>重试策略（Retry Rule）是 Rule 的级联，他采用 Round Robin Rule的 <code>choose()</code>方法来获取服务器实例，<code>最大重试次数（maxRetryMillis）</code> 是 <strong>500</strong>，因此他在选择实例和重试方法是：</p>
<blockquote>
<p>级联（cascade）在计算机科学中指多个对象之间一对多的映射关系，可以理解为一张表 A 用于存放学生所在班级（姓名、性别、年龄）而姓名作为主键，而另一张表 B 存放着楼层住户信息（姓名、性别）他们之间通过 <strong>姓名、年龄</strong> 来作为级联</p>
</blockquote>
<ol>
<li><p>如果通过 <code>choose()</code> 方法获取服务器实例正常，则回答并返回数据</p>
</li>
<li><p>假设超过了 <code>最大的重试次数（maxRetryMillis）</code> 没有获取到 “活着的服务器”，则返回 null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((answer == <span class="literal">null</span>) || (!answer.isAlive())) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后如果没有活着的服务回答在当前时间小于 <code>500 ms</code> 的情况下，则会不断的在这时间段重试。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((answer == <span class="literal">null</span>) || (!answer.isAlive()))</span><br><span class="line">		&amp;&amp; (System.currentTimeMillis() &lt; deadline)) &#123;</span><br><span class="line">	<span class="comment">/* pause and retry hoping it&#x27;s transient */</span></span><br><span class="line">	Thread.yield();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加权响应时间策略（WeightedResponseTimeRule）"><a href="#加权响应时间策略（WeightedResponseTimeRule）" class="headerlink" title="加权响应时间策略（WeightedResponseTimeRule）"></a>加权响应时间策略（WeightedResponseTimeRule）</h4><p>WeightedResponseTimeRule 是 <code>RoundRobinRule</code> 的延伸，对一些功能进行了扩展、可以根据服务实例的运行情况计算出服务实例的权重，之后进行服务实例的挑选。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lb == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// get hold of the current reference in case it is changed from the other thread</span></span><br><span class="line">        List&lt;Double&gt; currentWeights = accumulatedWeights;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Server&gt; allList = lb.getAllServers();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">serverCount</span> <span class="operator">=</span> allList.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (serverCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">serverIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// last one in the list is the sum of all weights</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">maxTotalWeight</span> <span class="operator">=</span> currentWeights.size() == <span class="number">0</span> ? <span class="number">0</span> : currentWeights.get(currentWeights.size() - <span class="number">1</span>); </span><br><span class="line">        <span class="comment">// No server has been hit yet and total weight is not initialized</span></span><br><span class="line">        <span class="comment">// fallback to use round robin</span></span><br><span class="line">        <span class="keyword">if</span> (maxTotalWeight &lt; <span class="number">0.001d</span>) &#123;</span><br><span class="line">            server =  <span class="built_in">super</span>.choose(getLoadBalancer(), key);</span><br><span class="line">            <span class="keyword">if</span>(server == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> server;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// generate a random weight between 0 (inclusive) to maxTotalWeight (exclusive)</span></span><br><span class="line">            <span class="type">double</span> <span class="variable">randomWeight</span> <span class="operator">=</span> random.nextDouble() * maxTotalWeight;</span><br><span class="line">            <span class="comment">// pick the server index based on the randomIndex</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Double d : currentWeights) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d &gt;= randomWeight) &#123;</span><br><span class="line">                    serverIndex = n;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            server = allList.get(serverIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Transient. */</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (server.isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> (server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Next.</span></span><br><span class="line">        server = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在 <code>choose</code> 方法获取服务实例时，如果服务负载均衡器和所有访问器为空，则返回 null</li>
<li>之后当前所有服务的索引的最后一位，则是所有权重的总和，之后生成 <strong>0～总和</strong> 的随机权重</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;Weight adjusting job started&quot;</span>);</span><br><span class="line">            <span class="type">AbstractLoadBalancer</span> <span class="variable">nlb</span> <span class="operator">=</span> (AbstractLoadBalancer) lb;</span><br><span class="line">            <span class="type">LoadBalancerStats</span> <span class="variable">stats</span> <span class="operator">=</span> nlb.getLoadBalancerStats();</span><br><span class="line">            <span class="keyword">if</span> (stats == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// no statistics, nothing to do</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">double</span> <span class="variable">totalResponseTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// find maximal 95% response time</span></span><br><span class="line">            <span class="keyword">for</span> (Server server : nlb.getAllServers()) &#123;</span><br><span class="line">                <span class="comment">// this will automatically load the stats if not in cache</span></span><br><span class="line">                <span class="type">ServerStats</span> <span class="variable">ss</span> <span class="operator">=</span> stats.getSingleServerStat(server);</span><br><span class="line">                totalResponseTime += ss.getResponseTimeAvg();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// weight for each server is (sum of responseTime of all servers - responseTime)</span></span><br><span class="line">            <span class="comment">// so that the longer the response time, the less the weight and the less likely to be chosen</span></span><br><span class="line">            <span class="type">Double</span> <span class="variable">weightSoFar</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// create new list and hot swap the reference</span></span><br><span class="line">            List&lt;Double&gt; finalWeights = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Double&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Server server : nlb.getAllServers()) &#123;</span><br><span class="line">                <span class="type">ServerStats</span> <span class="variable">ss</span> <span class="operator">=</span> stats.getSingleServerStat(server);</span><br><span class="line">                <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> totalResponseTime - ss.getResponseTimeAvg();</span><br><span class="line">                weightSoFar += weight;</span><br><span class="line">                finalWeights.add(weightSoFar);   </span><br><span class="line">            &#125;</span><br><span class="line">            setWeights(finalWeights);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Error calculating server weights&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            serverWeightAssignmentInProgress.set(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这其中作为最终要的角色则是 <code>DynamicServerWeightTask</code> 方法，主要通过 <code>totalResponseTime（总响应时间）</code> 来计算权重，其原理就是使用 <code>ServerStats</code> 在负载均衡器中捕获每个服务器的各种统计信息，那么总响应时间就是通过他的 <code>getResponseTimeAvg</code> 方法获取处理请求的平均总时间，以毫秒为单位，这个过程主要找到最大 95% 的响应时间</p>
<p>这样每个服务器的权重就是 所有服务器响应时间的总和减去响应时间 <code>（totalResponseTime - getResponseTimeAvg）</code> 这样得出的结果就是 <strong>响应时间越长则权重越小，则选中的几率就很小</strong></p>
<h4 id="随机策略（RandomRule）"><a href="#随机策略（RandomRule）" class="headerlink" title="随机策略（RandomRule）"></a>随机策略（RandomRule）</h4><p>RandomRule 主要是一个在现有服务器之间随机分配流量的负载均衡，他主要的步骤是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lb == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Server&gt; upList = lb.getReachableServers();</span><br><span class="line">            List&lt;Server&gt; allList = lb.getAllServers();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">serverCount</span> <span class="operator">=</span> allList.size();</span><br><span class="line">            <span class="keyword">if</span> (serverCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * No servers. End regardless of pass, because subsequent passes</span></span><br><span class="line"><span class="comment">                 * only get more restrictive.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> rand.nextInt(serverCount);</span><br><span class="line">            server = upList.get(index);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * The only time this should happen is if the server list were</span></span><br><span class="line"><span class="comment">                 * somehow trimmed. This is a transient condition. Retry after</span></span><br><span class="line"><span class="comment">                 * yielding.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server.isAlive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> (server);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Shouldn&#x27;t actually happen.. but must be transient or a bug.</span></span><br><span class="line">            server = <span class="literal">null</span>;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>通过<code>choose</code> 方法获取到服务器实例，如果负载均衡器和服务器为0则返回 <code>null</code></li>
<li>首先他会通过 <code>upList</code> 以及 <code>allList()</code> 分别获取存活服务器列表和所有服务器列表，之后通过 <code>Random</code> 来生成一个随机数生成器</li>
<li>如果服务器正常运行，则返回该服务，并对可以请求的服务器标注一个随机的值，这就让每次通过 <code>choose</code> 方法获取到的服务器实例都会有一个随机的标注。</li>
</ol>
<h4 id="客户端配置启用线性轮询策略（ClientConfigEnabledRoundRobinRule）"><a href="#客户端配置启用线性轮询策略（ClientConfigEnabledRoundRobinRule）" class="headerlink" title="客户端配置启用线性轮询策略（ClientConfigEnabledRoundRobinRule）"></a>客户端配置启用线性轮询策略（ClientConfigEnabledRoundRobinRule）</h4><p>客户端配置启用线性轮询策略，从名字上可以看出他就是为了启用 <code>RoundRobinRule</code> 策略的，因此他的整个流程都是通过 <code>RoundRobinRule</code> 来使用负载均衡器。而 <code>choose</code> 方法则也是通过 <code>RoundRobinRule</code> 来实现的，如果没有使用他则会出现 ：“This class has not been initialized with the RoundRobinRule class” 的报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientConfigEnabledRoundRobinRule</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalancerRule</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">RoundRobinRule</span> <span class="variable">roundRobinRule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoundRobinRule</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> &#123;</span><br><span class="line">        roundRobinRule = <span class="keyword">new</span> <span class="title class_">RoundRobinRule</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoadBalancer</span><span class="params">(ILoadBalancer lb)</span> &#123;</span><br><span class="line">    	<span class="built_in">super</span>.setLoadBalancer(lb);</span><br><span class="line">    	roundRobinRule.setLoadBalancer(lb);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (roundRobinRule != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> roundRobinRule.choose(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;This class has not been initialized with the RoundRobinRule class&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最大空闲策略（BestAvailableRule）"><a href="#最大空闲策略（BestAvailableRule）" class="headerlink" title="最大空闲策略（BestAvailableRule）"></a>最大空闲策略（BestAvailableRule）</h4><p>该规则主要用于选择并发请求最少的服务器实例来提供服务，延伸自 <code>ClientConfigEnabledRoundRobinRule</code>，通过 <code>LoadBalancerStats</code> 来统计每个服务器的特征和信息，以此来过滤失败的服务实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (loadBalancerStats == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.choose(key);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Server&gt; serverList = getLoadBalancer().getAllServers();</span><br><span class="line">    <span class="type">int</span> <span class="variable">minimalConcurrentConnections</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">Server</span> <span class="variable">chosen</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Server server: serverList) &#123;</span><br><span class="line">        <span class="type">ServerStats</span> <span class="variable">serverStats</span> <span class="operator">=</span> loadBalancerStats.getSingleServerStat(server);</span><br><span class="line">        <span class="keyword">if</span> (!serverStats.isCircuitBreakerTripped(currentTime)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">concurrentConnections</span> <span class="operator">=</span> serverStats.getActiveRequestsCount(currentTime);</span><br><span class="line">            <span class="keyword">if</span> (concurrentConnections &lt; minimalConcurrentConnections) &#123;</span><br><span class="line">                minimalConcurrentConnections = concurrentConnections;</span><br><span class="line">                chosen = server;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (chosen == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.choose(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> chosen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>loadBalancerStats</code> 不为 null，则找出最小的并发连接数（minimalConcurrentConnections）来使用。假设 <code>loadBalancerStats</code> 为 null，则通过 <code>ClientConfigEnabledRoundRobinRule</code> 类中的 <code>choose</code> 类来使用线性轮询策略。</p>
<h4 id="过滤线性轮询策略（PredicateBasedRule）"><a href="#过滤线性轮询策略（PredicateBasedRule）" class="headerlink" title="过滤线性轮询策略（PredicateBasedRule）"></a>过滤线性轮询策略（PredicateBasedRule）</h4><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210629013902.png"></p>
<p>过滤线性轮询策略主要在过滤给定的服务器列表和负载均衡器后，通过内部定义的一个过滤器来筛选出服务实例清单，之后通过线性轮询方式过滤服务实例，并从清单选取一个服务实例。</p>
<blockquote>
<figure class="highlight plaintext"><figcaption><span>是服务器过滤逻辑的基本构建块，可用于规则和服务器列表过滤器。 谓词的输入对象是PredicateKey，里面有Server和负载均衡器的key信息。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">   public Server choose(Object key) &#123;</span><br><span class="line">       ILoadBalancer lb = getLoadBalancer();</span><br><span class="line">       Optional&lt;Server&gt; server = getPredicate().chooseRoundRobinAfterFiltering(lb.getAllServers(), key);</span><br><span class="line">       if (server.isPresent()) &#123;</span><br><span class="line">           return server.get();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="AbstractServerPredicate"><a href="#AbstractServerPredicate" class="headerlink" title="AbstractServerPredicate"></a>AbstractServerPredicate</h5><p>过滤线性轮询的主要功能主要通过 <code>AbstractServerPredicate</code> 进行实现，而 <code>AbstractServerPredicate</code> 是 <code>Predicate</code> 的实现。</p>
<blockquote>
<figure class="highlight plaintext"><figcaption><span>主要是用于确定给定输入的 true 或 false，因此也被称之为 “谓词”。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; 在数学逻辑中，谓词通常使用大写罗马字母表示，如P、Q、R这些，根据其变量值来可能为 “真假（true or false）” 的陈述。</span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt; 也可以理解为一个运算符或函数（布尔值函数），根据输入来返回一个 false or true。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 在初始阶段，他主要会通过 ```LoadBalancerStats``` 来获取负载均衡器的统计信息</span><br><span class="line">   1. 如果为空则返回负载均衡器的信息。</span><br><span class="line">   2. 不为空的话获取负载均衡器（```ILoadBalancer```），在获取负载均衡器的统计信息，并返回设置的负载均衡器统计信息（```setLoadBalancerStats```）。</span><br><span class="line">       1. 如果未找到 LoadalancerStats 未找到则返回 null</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">   protected LoadBalancerStats getLBStats() &#123;</span><br><span class="line">       if (lbStats != null) &#123;</span><br><span class="line">           return lbStats;</span><br><span class="line">       &#125; else if (rule != null) &#123;</span><br><span class="line">           ILoadBalancer lb = rule.getLoadBalancer();</span><br><span class="line">           if (lb instanceof AbstractLoadBalancer) &#123;</span><br><span class="line">               LoadBalancerStats stats =  ((AbstractLoadBalancer) lb).getLoadBalancerStats();</span><br><span class="line">               setLoadBalancerStats(stats);</span><br><span class="line">               return stats;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="2">
<li>之后通过 <code>getServerOnlyPredicate</code> 来获取布尔值函数（即谓词），并通过 <code>getEligibleServers</code> 筛选出合格的服务器。最后使用 <code>chooseRandomlyAfterFiltering</code> 方法筛选并随机选择服务器实例，最后也可以通过 <code>chooseRoundRobinAfterFiltering</code> 方法来创建循环选择过筛选后的服务器实例。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;Server&gt; <span class="title function_">chooseRandomlyAfterFiltering</span><span class="params">(List&lt;Server&gt; servers)</span> &#123;</span><br><span class="line">    List&lt;Server&gt; eligible = getEligibleServers(servers);</span><br><span class="line">    <span class="keyword">if</span> (eligible.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.absent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(eligible.get(random.nextInt(eligible.size())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Choose a server in a round robin fashion after the predicate filters a list of servers. Load balancer key </span></span><br><span class="line"><span class="comment"> * is presumed to be null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;Server&gt; <span class="title function_">chooseRoundRobinAfterFiltering</span><span class="params">(List&lt;Server&gt; servers)</span> &#123;</span><br><span class="line">    List&lt;Server&gt; eligible = getEligibleServers(servers);</span><br><span class="line">    <span class="keyword">if</span> (eligible.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.absent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(eligible.get(nextIndex.getAndIncrement() % eligible.size()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Choose a random server after the predicate filters list of servers given list of servers and</span></span><br><span class="line"><span class="comment"> * load balancer key. </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;Server&gt; <span class="title function_">chooseRandomlyAfterFiltering</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> &#123;</span><br><span class="line">    List&lt;Server&gt; eligible = getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">    <span class="keyword">if</span> (eligible.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.absent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(eligible.get(random.nextInt(eligible.size())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Choose a server in a round robin fashion after the predicate filters a given list of servers and load balancer key. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;Server&gt; <span class="title function_">chooseRoundRobinAfterFiltering</span><span class="params">(List&lt;Server&gt; servers, Object loadBalancerKey)</span> &#123;</span><br><span class="line">    List&lt;Server&gt; eligible = getEligibleServers(servers, loadBalancerKey);</span><br><span class="line">    <span class="keyword">if</span> (eligible.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.absent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.of(eligible.get(nextIndex.getAndIncrement() % eligible.size()));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AbstractServerPredicate <span class="title function_">ofKeyPredicate</span><span class="params">(<span class="keyword">final</span> Predicate&lt;PredicateKey&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AbstractServerPredicate</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@edu</span>.umd.cs.findbugs.annotations.SuppressWarnings(value = <span class="string">&quot;NP&quot;</span>)</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(PredicateKey input)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p.apply(input);</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create an instance from a predicate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AbstractServerPredicate <span class="title function_">ofServerPredicate</span><span class="params">(<span class="keyword">final</span> Predicate&lt;Server&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AbstractServerPredicate</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@edu</span>.umd.cs.findbugs.annotations.SuppressWarnings(value = <span class="string">&quot;NP&quot;</span>)</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(PredicateKey input)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p.apply(input.getServer());</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="区域感知轮询策略（ZoneAvoidanceRule）"><a href="#区域感知轮询策略（ZoneAvoidanceRule）" class="headerlink" title="区域感知轮询策略（ZoneAvoidanceRule）"></a>区域感知轮询策略（ZoneAvoidanceRule）</h5><p>该策略是 <strong>过滤线性轮询策略（PredicateBasedRule）</strong> 的实现类，主要以 <strong>区域和可用性过滤服务器的规则</strong> 为基础，也通过组合过滤条件和该策略本身的过滤条件相辅相成，而 AbstractServerPredicate 则为次过滤条件。</p>
<p>他的过滤条件也非常的简单，首先，需要通过 <code>randomChooseZone</code> 来随机选择服务器，之后 <code>selectedZone</code> 来选择区域并返回，之后 <code>totalServerCount</code> 统计服务器总数，以及获取实例数（<code>getInstanceCount</code>）。</p>
<p>在配合 <code>index</code> 和 <code>sum</code>，其中 index 及服务器总数，每发现一个 +1。而 <code>sum</code> 则是实例数的总和，当服务总数小于总和时，那么将会选择该区域并返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String <span class="title function_">randomChooseZone</span><span class="params">(Map&lt;String, ZoneSnapshot&gt; snapshot,</span></span><br><span class="line"><span class="params">        Set&lt;String&gt; chooseFrom)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (chooseFrom == <span class="literal">null</span> || chooseFrom.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">selectedZone</span> <span class="operator">=</span> chooseFrom.iterator().next();</span><br><span class="line">    <span class="keyword">if</span> (chooseFrom.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> selectedZone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalServerCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String zone : chooseFrom) &#123;</span><br><span class="line">        totalServerCount += snapshot.get(zone).getInstanceCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> random.nextInt(totalServerCount) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String zone : chooseFrom) &#123;</span><br><span class="line">        sum += snapshot.get(zone).getInstanceCount();</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= sum) &#123;</span><br><span class="line">            selectedZone = zone;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> selectedZone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当选择完后，就是通过 <code>availableZones</code> 方法获取可用区域，如果可用区数量等于1，则返回可用区（<code>availableZones</code>），当实例数为0时，开始移出可用区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (availableZones.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> availableZones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移出可用区的方式有很多，其中就是 <strong>获取心跳次数除于实例总数大于等于服务无回应百分比或每台服务器负载</strong>，小于0的，也会被移出可用区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((<span class="type">double</span>) zoneSnapshot.getCircuitTrippedCount())</span><br><span class="line">                        / instanceCount &gt;= triggeringBlackoutPercentage</span><br><span class="line">                        || loadPerServer &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    availableZones.remove(zone);</span><br><span class="line">                    limitedZoneAvailability = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>或者说每台服务器负载（<code>loadPerServer</code>）减去每台服务器最大负载（<code>maxLoadPerServer</code>）小于 0.000001d，则会被添加至最差区域（<code>worstZones</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Math.abs(loadPerServer - maxLoadPerServer) &lt; <span class="number">0.000001d</span>) &#123;</span><br><span class="line">    <span class="comment">// they are the same considering double calculation</span></span><br><span class="line">    <span class="comment">// round error</span></span><br><span class="line">    worstZones.add(zone);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (loadPerServer &gt; maxLoadPerServer) &#123;</span><br><span class="line">    maxLoadPerServer = loadPerServer;</span><br><span class="line">    worstZones.clear();</span><br><span class="line">    worstZones.add(zone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以通过每台服务器负载（<code>loadPerServer</code>）大于服务器最大负载（<code>maxLoadPerServer</code>）的方式让其加入到最差区域中。</p>
<p>至于随机选择区（<code>randomChooseZon</code>），如果不为0，也会被移出可用区（因为避免区域被你霸占了），否则返回可用区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">String</span> <span class="variable">zoneToAvoid</span> <span class="operator">=</span> randomChooseZone(snapshot, worstZones);</span><br><span class="line">    <span class="keyword">if</span> (zoneToAvoid != <span class="literal">null</span>) &#123;</span><br><span class="line">        availableZones.remove(zoneToAvoid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> availableZones;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，当一系列的区域过滤完成后，通过线性轮询的方式从过滤结果中选出一个服务实例。</p>
<h4 id="可用性过滤策略（AvailabilityFilteringRule）"><a href="#可用性过滤策略（AvailabilityFilteringRule）" class="headerlink" title="可用性过滤策略（AvailabilityFilteringRule）"></a>可用性过滤策略（AvailabilityFilteringRule）</h4><p>该策略根据宕机或超过请求时限的活动连接来分配权重，他是 <code>PredicateBasedRule</code> 的延伸，其主要还是通过 <code>AbstractServerPredicate</code> 来实现具体的功能。</p>
<h3 id="Ribbon-负载均衡策略自定义"><a href="#Ribbon-负载均衡策略自定义" class="headerlink" title="Ribbon 负载均衡策略自定义"></a>Ribbon 负载均衡策略自定义</h3><p>自定义负载均衡策略需要先运行 <strong>consul</strong> 除服务消费者之外的集群，之后新建项目添加依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-netflix-ribbon&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.0.3&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/com.netflix.ribbon/ribbon-loadbalancer --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.netflix.ribbon&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;ribbon-loadbalancer&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.7.18&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h4 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">Ribbon Rule</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">9003</span></span><br><span class="line"><span class="attr">spring.cloud.consul.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.service-name</span>=<span class="string">service-provider        # 服务提供者名字</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.register</span>=<span class="string">false                       # 是否注册服务</span></span><br></pre></td></tr></table></figure>

<h4 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h4><p>在启动类中通过 <code>@LoadBalancd</code> 以及 <code>@Bean</code> 来实例化 <code>restTemplate</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动类，通过 <span class="doctag">@LoadBalanced</span> 来开启客户端的负载均衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/06/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  实例化 RestTemplate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> RestTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="RibbonConfig"><a href="#RibbonConfig" class="headerlink" title="RibbonConfig"></a>RibbonConfig</h4><p>在配置类中启用 <code>Configuration</code> 注解，并使用 <code>RibbonClient</code> 来配置服务提供者名称，最后通过 <code>Bean</code> 注解实例化负载均衡策略（RandomRule）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.IRule;</span><br><span class="line"><span class="keyword">import</span> com.netflix.loadbalancer.RandomRule;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.ribbon.RibbonClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.ribbon.RibbonClientConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置类，通过 <span class="doctag">@RibbonClient</span> 注解来配置服务名以及实例化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/06/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RibbonClient(name = &quot;service-provider&quot;, configuration = RibbonClientConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RibbonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化 Ribbon 的随机策略（RandomRule）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> RandomRule</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IRule <span class="title function_">irule</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TestController"><a href="#TestController" class="headerlink" title="TestController"></a>TestController</h4><p>测试类主要用于通过负载均衡器来使用负载均衡策略实现选择服务实例的效果：</p>
<blockquote>
<p>运行后浏览器打开 <a target="_blank" rel="noopener" href="http://localhost:9003/hey">http://localhost:9003/hey</a> 每次刷新会得到不同的服务提供者实例返回的信息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalancerClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hey&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServiceInstance</span> <span class="variable">serviceInstance</span> <span class="operator">=</span> loadBalancerClient.choose(<span class="string">&quot;service-provider&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">callService</span> <span class="operator">=</span> <span class="string">&quot;Host: &quot;</span> + serviceInstance.getHost() + <span class="string">&quot; Port: &quot;</span> + serviceInstance.getPort() + <span class="string">&quot; Date:&quot;</span> + simpleDateFormat.format(date);</span><br><span class="line">        <span class="keyword">return</span> callService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><p>需要注意的是 Feign <strong>是除了 RestTemplate 客户端实现服务发现外</strong> ，可以实现服务发现的另一种方式，通过整合 Ribbon 好后可以提供负载均衡的功能。</p>
<p>Feign 与 Ribbon 最为不同的就是调用方式，通常情况下 Ribbon 需要自己构建一个 HTTP 请求，然后 RestTemplate 将该请求发送给其他服务，<code>RibbonClient(value = &quot;serverName&quot;)</code> 就印证了这一点。</p>
<p>而 Feign 是在 Ribbon 的基础上在进行一层封装，因为是采用接口的方式他并不需要自己构建 HTTP 请求。<strong>只需要将其他服务方法定义成抽象方法即可</strong>，<code>@FeignClient(&quot;ServerName&quot;)</code> 注解来调用服务。</p>
<blockquote>
<figure class="highlight plaintext"><figcaption><span>属性值应与服务中心方法名一致</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### Feign 工作流程</span><br><span class="line">上述这些与 Feugn 的工作原理密不可分，在正常的情况下他有四个步骤，分别为：</span><br><span class="line">![](https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210701034924.png)</span><br><span class="line"></span><br><span class="line">在这个过程中，如果使用了 ```@FeignClient``` 注解，那么 Feign 客户端将会创建一个动态代理。</span><br><span class="line">之后调用这个接口（即调用了 Feign 客户端所创建的动态代理），而 Feign 客户端的动态代理会根据接口上的 ```@RequestMapping``` 注解来构造出地址以及方法。</span><br><span class="line">最后发起请求并解析响应</span><br><span class="line"></span><br><span class="line">![](https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210701030423.png)</span><br><span class="line"></span><br><span class="line">服务提供者 **调用了** 定义 ```@FeignClient``` 注解的接口时，Feign 会构建一个动态代理，之后构造地址</span><br><span class="line">最终向接口发送请求（也就是服务提供者）</span><br><span class="line"></span><br><span class="line">#### Feign 负载均衡</span><br><span class="line">![](https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210701111804.gif)</span><br><span class="line">Feign 是一个声明式的 Web Servce 客户端，Spring cloud 客户端添加了Spring MVC 的支持，Feign 在整合了 Ribbon 后即可一共负载均衡的功能，在此之前我们需要添加依赖：</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>以及在 <code>application.properties</code> 全局配置文件中配置服务端口以及名称等：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">Feign Configuration</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8780</span></span><br><span class="line"><span class="attr">spring.cloud.consul.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.register</span>=<span class="string">false     </span></span><br></pre></td></tr></table></figure>

<p>然后在启动类中通过 <code>EnableDiscoveryClient</code> 来启用服务发现，并使用 <code>@EnableFeignClients</code> 注解来启动 Feign 客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动类，通过 <span class="doctag">@EnableDiscoveryClient</span> 实现服务中心，以及 <span class="doctag">@EnableFeignClients</span> 来支持 Feign</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h5><p>在配置类中我们主要用于实现使用默认契约，即 <code>Spring cloud Netfilx MVC Controller</code> 改为 <code>feign.Contract.Defaull</code> 原生契约。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feign.Contract;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义 Feign 配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 Spring cloud MVC Netfilx Controller 改为 feign.Contract.Defaull</span></span><br><span class="line"><span class="comment">     * 之后契约将默认改为 Feign 原生契约，之后可以使用默认注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> feign.Contract.Defaull</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Contract <span class="title function_">contract</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Contract</span>.Default();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h5><p>为了通过 consul 服务发现提供者，因此需要通过 <code>FeignClient</code> 注解来进行连接，也就是 Feign 工作流程中的 “构造地址‘，以及 Feign 的配置等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feign.RequestLine;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.config.FeignConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FeignClient 接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FeignClient(contextId = &quot;feignClient&quot;, name = &quot;service-provider&quot;, configuration = FeignConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FeignClientInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 <span class="doctag">@RequestLine</span> 将 Spring MVC 注解修改为原生的 <span class="doctag">@RequestLine</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> <span class="doctag">@RequestLine</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestLine(&quot;GET /hey&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hey</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h5><p>最后的 Feign 控制器则是为了提供服务，因此只需要通过调用 Feigin 接口即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.FeignClientInterface;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用接口以此来提供服务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    FeignClientInterface feignClientInterface;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hey&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> feignClientInterface.hey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Feign-记录日志"><a href="#Feign-记录日志" class="headerlink" title="Feign 记录日志"></a>Feign 记录日志</h4><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210701155448.png"></p>
<p>在 Feign 中，记录日志的等级可以分为四个，分别为：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>DA</th>
</tr>
</thead>
<tbody><tr>
<td>NONE</td>
<td>不记录（默认）</td>
</tr>
<tr>
<td>BASIC</td>
<td>只记录和请求方法、URL、相应状态码以及执行时间</td>
</tr>
<tr>
<td>HEADERS</td>
<td>只记录基本信息，请求和响应的标题</td>
</tr>
<tr>
<td>FULL</td>
<td>记录请求、响应的标题以及正文和元数据</td>
</tr>
</tbody></table>
<p>在 Feigin 负载均衡的基础上，我们实际上只需要修改或添加 <code>config</code> 包下的 <code>FeignConfig</code> 类即可：</p>
<h5 id="FeignConfig"><a href="#FeignConfig" class="headerlink" title="FeignConfig"></a>FeignConfig</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feign.Contract;</span><br><span class="line"><span class="keyword">import</span> feign.Logger;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义 Feign 配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 Spring cloud MVC Controller 改为 feign.Contract.Defaull</span></span><br><span class="line"><span class="comment">     * 之后契约将默认改为 Feign 原生契约，之后可以使用默认注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> feign.Contract.Defaull</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Contract <span class="title function_">contract</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Contract</span>.Default();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志管理器记录等级为 FULL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Logger.Level.Full</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.Level <span class="title function_">level</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Logger 是一个日志管理器，与 level 组合为 <code>Logger.Level</code> 即日志管理器等级</p>
</blockquote>
<h5 id="application-properties-1"><a href="#application-properties-1" class="headerlink" title="application.properties"></a>application.properties</h5><p>之后在 <code>applicatin.properties</code> 全局配置文件中添加 <code>logging.level.com.example.demo=DEBUG</code> 来开启记录日志的包：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">Feign Configuration</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8780</span></span><br><span class="line"><span class="attr">spring.cloud.consul.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.register</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">logging.level.com.example.demo</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>
	

	

</article>




	<article>
	
		<h1><a href="/2022/04/21/java/spring cloud/6.Spring cloud Consul/">Spring cloud Consul</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2022-04-21</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-none-link" href="/tags/java/" rel="tag">java</a> <a class="article__tag-none-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a>
			</span>
		
	</div>

	

	
		<p>Spring cloud Consul 是由 HashiCorp 公司使用 Go lang 所开发的一个 <strong>服务治理</strong> 项目，主要包含了 <strong>服务治理、健康检查、Key-value 存储、多数据中心</strong> 的功能。与 其他服务中心相比，Consul 支持多数据中心，内外网服务采用不同的端口号进行监听，除此之外还可以避免单数据中心故障所导致的问题。</p>
<p>Consul 所使用的是 Raft（Reliable, Replicated, Redundant,d Fault An-Tolerant，可靠、可复制、可沉余、可容错） 算法来保证一致性，相比 Poxos，Raft 的目标则是提供更加清晰的逻辑分工使得算法本身可以被更好的理解。</p>
<h2 id="原理流程"><a href="#原理流程" class="headerlink" title="原理流程"></a>原理流程</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210616033154.png"></p>
<p>服务提供者（Service Provider）在启动时向 Consul 发送一个POST 请求，<strong>来告诉自己的 IP和端口号等信息</strong>。Consul 收到了服务提供者的注册后，默认每隔10s想服务提供者发送一个健康请求，来验证该提供者是否可以正常提供服务。</p>
<blockquote>
<p>Consul 中的服务提供者临时表每隔 10s 更新一次，只包含了通过健康检查的服务提供提供者。</p>
</blockquote>
<p>之后服务消费者（Service Consumer）在调用服务提供者之前会从 Consul 获取存储的服务提供者 IP 和地址的临时地址表，之后发送请求给 服务提供者。</p>
<h3 id="集群原理"><a href="#集群原理" class="headerlink" title="集群原理"></a>集群原理</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210616033200.png"></p>
<blockquote>
<p>Consul 的常见黑话有很多，如 Agent、Client、Server、DataCenter、Consensus、Gossip、LAN Gossip、WAN Gossip、RPC…… 他们的意思如下：</p>
<blockquote>
<p><strong>Agent</strong></p>
<blockquote>
<p>Consul 集群中每个成员都会运行 Agent，他是一个守护进程。主要分为 Server 与 Client 模式，能运行 DNS 或 HTTP 接口，<strong>负责在运行时检查和保持服务同步</strong>。</p>
</blockquote>
<p><strong>Client</strong></p>
<blockquote>
<p>Client 转发所有 RPC 到 Server 的代理，Client 想对于是无状态的，他唯一执行后台活动是加入 LAN Gossip 池。Client 只需要较低的资源开销，以及较少的网络流量带宽等。</p>
<blockquote>
<p><strong>RPC（Remote Procedure Call）远程过程调用</strong>，该协议允许一台计算机的程序调用另一台开放网络的计算机。在 Consul 集群中主要允许 Client 请求 Server 的请求&#x2F;响应机制</p>
</blockquote>
<blockquote>
<p><strong>LAN gooip</strong> 包含了所有与位于同一个局域网或同一个数据中心的所有节点</p>
<blockquote>
<p><strong>Gossip</strong> 主要用于实现基于 UDP 的随机点到点通信</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Server</strong></p>
<blockquote>
<p>具有扩展功能的代理，功能包括Raft选举、维护集群状态、响应 RPC差需、与其他数据中心交互 WAN gossip、转发查询给 Leader\远程数据中心。<br>他主要是在局域网内与本地客户端进行通信，通过广域网与其他数据中心进行通信，通常 Server保存集群中的配置信息（每个数据中心的 Server 数量建议为 3～5个）</p>
<blockquote>
<p><strong>Wan gooip</strong> 只包含分布在不同数据中心的所有节点，数据中心间通常采用互联网或广域网进行通信。</p>
</blockquote>
<p><strong>DataCenter</strong></p>
<blockquote>
<p>一个私有且低延迟和高宽带的网络环境</p>
</blockquote>
<p><strong>Consensus</strong></p>
<blockquote>
<p>Consensus 用于代表复制机的状态一致性，即用于表明 Server 与 领袖选举的事务顺序达成一致。</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h4 id="Gossip-and-Wan-and-LAN"><a href="#Gossip-and-Wan-and-LAN" class="headerlink" title="Gossip and Wan and LAN"></a>Gossip and Wan and LAN</h4><p>在 Consul 数据中心中，官方给我们最好的建议数量是三台到五台之间。这是经过深思熟虑思考之后所得到的结果，当很多台数据中心加入后，则达成共识的过程很慢，但只有1～2台数据中心可用性又不高，因此所得出的权衡利弊的数量为 3~5台之间。</p>
<h5 id="Gossip-（第六届ACM分布式计算原理年会论文集）"><a href="#Gossip-（第六届ACM分布式计算原理年会论文集）" class="headerlink" title="Gossip （第六届ACM分布式计算原理年会论文集）"></a>Gossip （第六届ACM分布式计算原理年会论文集）</h5><blockquote>
<p>Demers, Alan; Greene, Dan; Hauser, Carl; Irish, Wes; Larson, John; Shenker, Scott; Sturgis, Howard; Swinehart, Dan; Terry, Doug (1987-01-01). Epidemic Algorithms for Replicated Database Maintenance. Proceedings of the Sixth Annual ACM Symposium on Principles of Distributed Computing. PODC ‘87. New York, NY, USA: ACM. pp. 1–12. doi:10.1145&#x2F;41840.41841. ISBN 978-0897912396. S2CID 1889203.</p>
</blockquote>
<p>Gossip protocol 又称 Epidemic Protocol（流行病协议），该协议早在1987年发表在 ACM 论文 《Epidemic Algorithms for Replicated Database Maintenance》中，主要用于在分布式数据库系统中各个副本节点间的同步数据。</p>
<h6 id="八卦通信模型-Gossip-Protocol"><a href="#八卦通信模型-Gossip-Protocol" class="headerlink" title="八卦通信模型 (Gossip Protocol)"></a>八卦通信模型 (Gossip Protocol)</h6><p>无论喜欢与否，八卦在人类社会中扮演了重要的角色。Dunbar（一位人类学家）在具有争议的一本书中声称，语言的出现原因是允许闲聊，而闲聊的整个过程是不需要仔细思考和梳理的。</p>
<p>因此无论什么情况，毫无疑问这些流言蜚语仍然是一种在社会活动中传播非常优秀的。特别是传播速度非常狂，而这个过程对组织信息传播的企图具有一些抵抗力。</p>
<blockquote>
<p>Kimmel 在书中给出了许多关于人类八卦的例子和细节</p>
</blockquote>
<p>虽然八卦通常会被认为是一种传播手段，但是实际上并不仅仅是机器上的传递，而个经过处理的。具体流程为一个人收集、处理信息并将处理后的信息传递给其他人。<br> 在这个过程中信息至少会根据其兴趣进行过滤，这样一来最有趣的新闻在传播到每个人之前就不会停止传播。</p>
<p> 更复杂的化来讲，信息是逐渐改变的，这增加了过程的复杂性并可能导致突发行为，其中这个平台则充当了 “集体智能”的信息处理媒介。</p>
<h6 id="流行病传播模型-Epidemics-Protocol"><a href="#流行病传播模型-Epidemics-Protocol" class="headerlink" title="流行病传播模型 (Epidemics Protocol)"></a>流行病传播模型 (Epidemics Protocol)</h6><p>实际上这些八卦非常类似于流行病，病毒扮演着信息的角色，而感染者则扮演者了解信息的角色。在过去的几年当中 “病毒式营销” 的概念非常火爆，通过视频分享平台以及社交网络，广告商可以有意识的利用日益高效的传播八卦广告。</p>
<p> 而令人震惊或非常有趣的广告，特别是设计会有极大限度的提高机会，阅读者通常会通知他们的朋友等等。</p>
<h6 id="分布式系统设计灵感"><a href="#分布式系统设计灵感" class="headerlink" title="分布式系统设计灵感"></a>分布式系统设计灵感</h6><p><strong>第一原因</strong><br>八卦对于大型分布式系统来说非常有意义，主要有两个原因。其中之一就是设计新协议的灵感来源： Gossip 有几个吸引人的特性，如简单、速度、健壮等，除此还包含了缺乏中央控制的瓶颈。</p>
<p>这些特性对于大型分布式系统关键组成部分的 <strong>信息分发和集体信息处理（聚合）</strong> 非常重要。</p>
<p><strong>第二原因</strong><br>随着当今互联网的稳步发展，病毒和蠕虫的传播策略越来越为之复杂。受感染的计算机通常会组成网络（被称为 “僵尸网络”），能够进行协作和执行攻击等手法。</p>
<p> 这对互联网基础设施构成了非常重大的威胁，为应对这些网络的一个办法就是设防防止他们的传播，这需要对流行病有很好的了解才可预防。</p>
<p>在本篇论文中，我们主要关注流行病以及八卦作为设计高可用组织系统和服务的灵感作为来源。</p>
<h5 id="Gossip-in-Consul"><a href="#Gossip-in-Consul" class="headerlink" title="Gossip in Consul"></a>Gossip in Consul</h5><h6 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h6><p>Consul 使用 Gossip 协议来管理成员资格并向集群广播消息，通过 Serf 库所提供，所基于  “SWIM: Scalable Weakly-consistent Infection-style Process Group Membership Protocol” 论文并做了一些必要的修改。</p>
<h6 id="WAN-and-Lan"><a href="#WAN-and-Lan" class="headerlink" title="WAN and Lan"></a>WAN and Lan</h6><p>Consul 使用了两个不同的八卦池，分别称之为 <strong>Lan 与 Wan</strong> 池，每个数据中心都有一个 Lan 池，其中包含数据中心的所有成员（包括客户端和服务器）</p>
<p>Lan 池的主要作用是成员信息允许客户端自动发现服务器，以此来减少所需的配置量。在分布式故障检测中允许检测的工作由整个集群共享，而不是单个服务器进行， <strong>他包含了所有位于同一个局域网或者同一个数据中心的所有节点</strong></p>
<p>而 Wan 池是全局唯一的，无论数据中心如何，所有服务器都应参与WAN池。WAN 池提供成员信息允许服务器执行夸数据中心的请求。</p>
<p>故障检测允许 Consul 优雅的处理丢失连接的整个数据中心，或仅处理远程数据中心的单个服务器，<strong>他只包含了分布在不同数据中心的所有节点</strong></p>
<h4 id="集群实现原理"><a href="#集群实现原理" class="headerlink" title="集群实现原理"></a>集群实现原理</h4><h5 id="Leader-and-Client-amp-Server"><a href="#Leader-and-Client-amp-Server" class="headerlink" title="Leader and Client&amp;Server"></a>Leader and Client&amp;Server</h5><p>从上图可以得知，每个数据中心的 Client 以及 Server 是混合的，一般官方建议数据中心 Server 通常为 3~5 台。</p>
<blockquote>
<p>这是经过深思熟虑之后所得出的结果，因为如果有太多的机器加入则达成共识会变慢。但只有 1～2台的数据中心可用性又不高，于是 3~5台是最好的选择</p>
</blockquote>
<p>数据中心的领袖（Leader）是有一个额外工作的 Server，他是由所有 Server 选出的（Raft 协议），主要用于处理所有的查询和事务。由于需要遵一致性协议的要求，所以事物也必须被复制到其他所有节点中（CAP 协议）。</p>
<blockquote>
<p>每个数据中心的 Server 都是 Raft 节点集合的一部分，在这期间内如果有一个非领袖服务器收到了RPC请求，将会将请求转发给集群中的领袖服务器中。</p>
</blockquote>
<h5 id="WAN-and-LAN"><a href="#WAN-and-LAN" class="headerlink" title="WAN and LAN"></a>WAN and LAN</h5><p>为了允许数据中心能够以 “低耦合（Low-touch）”的方式发现彼此。那么通过 WAN gossip Pool 来只包含服务节点的信息，用于优化网络延迟，那么一个新的数据中心就很容易加入到现存的 WAN gooip 池中。</p>
<blockquote>
<p>无论数据中心如何，所有服务器都应参与WAN池的原因，所以服务也支持跨数据中心请求</p>
</blockquote>
<p>这个时候一个服务在收到了来自另一个数据中心的请求后，会随即将该请求转发给正确的数据中心的服务中。之后该服务再将请求转发给本地的领袖服务（Leader），这使得服务之间有一个很低的耦合。</p>
<p>由于 Consul 自身的一些优势，如提所提供的健康检查、链接缓存、以及复用等功能，使得跨数据中心请求都是相对快速且可靠的。</p>
<h2 id="Consul-集群实现"><a href="#Consul-集群实现" class="headerlink" title="Consul 集群实现"></a>Consul 集群实现</h2><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210619183625.png"></p>
<h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add -</span><br><span class="line">sudo apt-add-repository &quot;deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs) main&quot;</span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install consul</span><br></pre></td></tr></table></figure>

<blockquote>
<p>至于第二条命令可能很多 debian er 无法使用，我们需要安装 sudo apt-get install <code>software-properties-common</code> 软件包来解决你 <code>add-repository</code> 无法使用的情况</p>
<blockquote>
<p>当你执行第三条命令的时候，也就是 <code>update</code> 对于一些非常纯净的发行版，你可能还需要安装 <code>sudo apt-get install apt-transport-https</code></p>
</blockquote>
</blockquote>
<p>当安装完成后我们可以执行 <code>consul</code> 来验证是否安装成功：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">consul</span> </span><br><span class="line">Usage: consul [--version] [--help] &lt;command&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">Available commands are:</span><br><span class="line">    agent          Runs a Consul agent</span><br><span class="line">    catalog        Interact with the catalog</span><br><span class="line">    event          Fire a new event</span><br><span class="line">    exec           Executes a command on Consul nodes</span><br><span class="line">    force-leave    Forces a member of the cluster to enter the &quot;left&quot; state</span><br><span class="line">    info           Provides debugging information for operators.</span><br><span class="line">    join           Tell Consul agent to join cluster</span><br><span class="line">    keygen         Generates a new encryption key</span><br><span class="line">    keyring        Manages gossip layer encryption keys</span><br><span class="line">    kv             Interact with the key-value store</span><br><span class="line">    leave          Gracefully leaves the Consul cluster and shuts down</span><br><span class="line">    lock           Execute a command holding a lock</span><br><span class="line">    maint          Controls node or service maintenance mode</span><br><span class="line">    members        Lists the members of a Consul cluster</span><br><span class="line">    monitor        Stream logs from a Consul agent</span><br><span class="line">    operator       Provides cluster-level tools for Consul operators</span><br><span class="line">    reload         Triggers the agent to reload configuration files</span><br><span class="line">    rtt            Estimates network round trip time between nodes</span><br><span class="line">    snapshot       Saves, restores and inspects snapshots of Consul server state</span><br><span class="line">    validate       Validate config files/directories</span><br><span class="line">    version        Prints the Consul version</span><br><span class="line">    watch          Watch for changes in Consul</span><br></pre></td></tr></table></figure>

<h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>可以通过以开发者模式运行和服务器模式运行两种，可通过使用下述命令直接进行启动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">consul agent -dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">consul agent -server</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>or -server``` 的区别主要是开发者模式和服务器模式两种运行模式，而 **agent** 则是用于注册服务、运行健康检查的一个功能。每个数据中心都要求至少有一台 Agent (Server 模式) ，推荐于 3~5 台。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">他主要有 Client 模式和  Server 两种模式，其中 Client 模式主要是用于运行写上述的服务（注册服务、健康检查……）而 Server 则是主要接收这些功能查询后的数据。</span><br><span class="line"></span><br><span class="line">&gt; 当运行之后我们可以通过访问 [http://127.0.0.1:8500/](http://127.0.0.1:8500/) 来进行查看和管理 Consul 集群状态</span><br><span class="line"></span><br><span class="line">**常用命令**</span><br><span class="line"></span><br><span class="line">| ID | DA | FA |</span><br><span class="line">| --- | --- | --- | </span><br><span class="line">| members | 列出 Consul 下集群成员 | |</span><br><span class="line">| | -datailed | 查看 Consul  集群成员详细信息 | |</span><br><span class="line">| monitor | 持续打印当前 Consul 代理流日志 | |</span><br><span class="line">| agent | 运行 Consul 代理 | |</span><br><span class="line">| | -dev | 开发者模式 |</span><br><span class="line">| | -server | 服务器模式 |</span><br><span class="line">| join | 加入某个集群 | |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### vagrant init</span><br><span class="line">Consul 集群的实现也非常简单，但多出了 ```join``` 参数，主要是加入集群。而在测试环境中，在正常且资金不允许的情况下我们是不会上服务器的，所以上也有很多文章出现了一些迷惑性文章。</span><br><span class="line"></span><br><span class="line">比如，运行 ```xxx``` 命令，之后执行 ```join```，这就很无语。首先，我们只要运行一个单个 consul 集群就会发现，他 **并不是交互式的**，你这个终端就挂着这个，之后你在开个新终端，来加入他，这也合理。</span><br><span class="line"></span><br><span class="line">&gt; 不要问为什么是 Vagrant 问就是 HashiCorp 项目下的（与 Consul 一个公司出的）</span><br><span class="line"></span><br><span class="line">但是最不合理的情况发现了，就是 ```-bind``` 参数下到底要填写什么。通常情况下我们会通过 vagrant 来部署测试环境进行实现。</span><br><span class="line"></span><br><span class="line">但幸运的是我们不需要单个手动配置 Vagrant 环境，只需要下载 Consul 所为我们提供的集群测试环境即可（实际上就是两个 debian 装个 Consul）：[https://github.com/hashicorp/consul/blob/master/demo/vagrant-cluster/Vagrantfile](https://github.com/hashicorp/consul/blob/master/demo/vagrant-cluster/Vagrantfile)</span><br><span class="line"></span><br><span class="line">我们可以选择手动安装或自动安装，即执行 ```vagrant up``` 根据 **Vagrantfile** 文件内配置执行一些命令。如 Consul 所提供的则是自动安装 Consul，则可能会造成卡住的问题，读者可自行进行解决。</span><br><span class="line"></span><br><span class="line">当配置好测试环境后，我们即拥有了三台测试环境，分别为 vagrant box#2 以及自己本机的环境，我们要保证这三台环境内可以正常启动 consul 以及其他等等，之后即可进入下一步。</span><br><span class="line"></span><br><span class="line">#### localhost</span><br><span class="line">我们首先需要将我们本机成为整个集群中的 **领导者（server/leader）**，之后剩下的 n1、n2 则扮演客户端的角色进行：</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">consul agent -dev -node=consul-server -bind=172.20.20.1 -data-dir=data -client 0.0.0.0</span><br></pre></td></tr></table></figure>

<p>通过上述命令，我们主要开启了 <strong>测试</strong> 模式下的 consul ui ，可通过访问 <a target="_blank" rel="noopener" href="http://localhost:8500/ui">http://localhost:8500/ui</a> 来直接进行通过可视化的方式观察集群状态。</p>
<blockquote>
<figure class="highlight plaintext"><figcaption><span>参数为本机器的 IP 地址。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在实际的生产环境中，我们时候使用的则是 ```consul agent -server -bootstrap-expect=2 -node=consul-server -bind=172.20.20.1 -data-dir=data -client 0.0.0.0``` 来通过 ```bootstrap-expect``` 限制集群数量等。</span><br><span class="line"></span><br><span class="line">而生产环境是不需要可视化 ui的，因此我们可以通过下面几个 api 接口来进行查看：</span><br><span class="line"></span><br><span class="line">| ID | DA | </span><br><span class="line">| --- | --- |</span><br><span class="line">| ip:port/v1/status/leader | 显示当前集群的领袖服务器 |</span><br><span class="line">| ip:port/v1/agent/members | 显示集群中所有成员信息 |</span><br><span class="line">| ip:port/v1/status/peers | 显示当前集群中的 Server 成员 |</span><br><span class="line">| ip:port/v1/catalog/services | 显示所有服务 |</span><br><span class="line">| ip:port/v1/catalog/nodes | 显示集群节点的详细信息 |</span><br><span class="line"></span><br><span class="line">#### vagrant up</span><br><span class="line">![](https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210619183721.png)</span><br><span class="line">##### n1</span><br><span class="line">在 n1 中，我们可以通过使用 ```vagrant ssh n1``` 直接进入 n1 的 debian 环境，之后建立一个目录也可以之际运行：</span><br><span class="line"></span><br><span class="line">需要注意的是当 ```vagrant init``` 完事之后，才可以使用 ```vagrant up``` 来进行启动，最后通过 ```vagrant shell n1``` 来选择进入多个环境下进行工作。</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">consul agent -node=client-one -bind=172.20.20.10 -enable-script-checks=true -data-dir=data</span><br></pre></td></tr></table></figure>
</blockquote>
<p>通过使用 <code>enable-script-checks</code> 来开启 consul 的健康检查，我们也可以在开一个 n1 交互式 shell 进行加入服务集群：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul join 172.20.20.1</span><br></pre></td></tr></table></figure>

<h5 id="n2"><a href="#n2" class="headerlink" title="n2"></a>n2</h5><p>n2 的流程和步骤也基本上和 n1 相差无几，我们也是通过 <code>vagrant ssh n2</code> 进入环境，之后根据自己喜好决定是否建立新的目录（主要存储文件）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul agent -node=client-two -bind=172.20.20.11 -enable-script-checks=true -data-dir=data</span><br></pre></td></tr></table></figure>

<p>之后你可以在建立一个 shell n2 连接来加入 consul-server 集群中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul join 172.20.20.1</span><br></pre></td></tr></table></figure>

<h2 id="服务提供者以及服务消费者"><a href="#服务提供者以及服务消费者" class="headerlink" title="服务提供者以及服务消费者"></a>服务提供者以及服务消费者</h2><p>通过 Consul 实现服务提供者和服务消费者之前，我们首先需要在构建项目中选择 <code>Spring web、Spring Boot Actuator、Consul Discovery</code> 等项目的依赖，当然也可以在 pom.xml 文件下进行添加：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之后我们的服务消费者不需要 <code>spring-boot-starter-actuator</code> 依赖。</p>
<h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210620003322.png"><br>我们首先模仿下真实环境下的三台服务器，分别运行着功能服务，因此我们主要通过 <code>.properties</code> 进行实现和模拟这个环境。在此之前，我们首先需要对启动类中添加 Consul 的服务注册注解 <code>@EnableDiscoveryClient</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DemoApplication.class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2021/6/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h4><h5 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">consul-provider</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8501</span></span><br><span class="line"><span class="attr">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.service-name</span>=<span class="string">service-provider</span></span><br><span class="line"><span class="attr">provider.name</span>=<span class="string">provider</span></span><br><span class="line"><span class="attr">logging.level.ROOT</span>=<span class="string">info</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是 <code>spring cloud consul discovery service-name</code> 是一个 spring cloud consul 发现服务时的名称，而 <code>logging.level.ROOT</code> 则是用于描述日志等级的。</p>
<h5 id="application-consul-provider-one-properties"><a href="#application-consul-provider-one-properties" class="headerlink" title="application-consul-provider-one.properties"></a>application-consul-provider-one.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">consul-provider-one</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8502    </span></span><br><span class="line"><span class="attr">spring.cloud.consul.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.service-name</span>=<span class="string">service-provider</span></span><br><span class="line"><span class="attr">provider.name</span>=<span class="string">provider-one</span></span><br></pre></td></tr></table></figure>
<h5 id="application-consul-provider-two-properties"><a href="#application-consul-provider-two-properties" class="headerlink" title="application-consul-provider-two.properties"></a>application-consul-provider-two.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">consul-provider-two</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8503</span></span><br><span class="line"><span class="attr">spring.cloud.consul.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.service-name</span>=<span class="string">service-provider</span></span><br><span class="line"><span class="attr">provider.name</span>=<span class="string">provider-two</span></span><br></pre></td></tr></table></figure>

<h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><h5 id="HeyController-java"><a href="#HeyController-java" class="headerlink" title="HeyController.java"></a>HeyController.java</h5><p>当配置完启动类和全局文件之后，我们首先需要实现服务提供的接口信息，所提供的也非常简单，就是 <code>.properties</code> 文件的内容获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HeyController.class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/06/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeyController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;provider.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hey&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;提供者名称：&quot;</span> + name + <span class="string">&quot; 端口号为：&quot;</span> + port;</span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="run-1"><a href="#run-1" class="headerlink" title="run"></a>run</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -jar demo-0.0.1-SNAPSHOT.jar --spring.profiles.active=consul-provider-one</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -jar demo-0.0.1-SNAPSHOT.jar --spring.profiles.active=consul-provider-two</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java -jar demo-0.0.1-SNAPSHOT.jar</span></span><br></pre></td></tr></table></figure>

<p>读者可能非常疑惑 <code>spring.profiles.active</code> 的作用是什么，实际上 <code>profiles</code> 是 <strong>pro(perties</strong> 的缩写，与 <strong>file</strong> 相加所等于的 profiles。可以理解为当多个 properties 文件时，运行那个配置文件，之后访问 ip:8501&#x2F;hey、8502&#x2F;hey、8503&#x2F;hey 都可以看到返回的信息。</p>
<h3 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="application-properties-1"><a href="#application-properties-1" class="headerlink" title="application.properties"></a>application.properties</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">consul-consumer</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8504</span></span><br><span class="line"><span class="attr">spring.cloud.consul.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.register</span>=<span class="string">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为服务消费者并不需要提供服务，所以我们可以选择通过 <code>spring.cloud.consul.discovery.register=false</code>，让其不注册服务到 consul 集群中</p>
<h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210620003305.gif"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalancerClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HeyController.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/06/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired()</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hey&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServiceInstance</span> <span class="variable">serviceInstance</span> <span class="operator">=</span> loadBalancerClient.choose(<span class="string">&quot;service-provider&quot;</span>);</span><br><span class="line">        <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> serviceInstance.getUri();</span><br><span class="line">        <span class="type">String</span> <span class="variable">callService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>().getForObject(uri + <span class="string">&quot;/hey&quot;</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> callService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这其中起到主要作用的就是 <code>RestTemplate</code>，他起到了服务提供者负载均衡的功能。假设我们有三台服务提供者，那么我们每次刷新服务消费者时，会出现不同的服务名称及端口号等信息。</p>

	

	

</article>




	<article>
	
		<h1><a href="/2022/04/21/java/spring cloud/5.Spring cloud Raft and CAP/">Spring cloud Raft and CAP</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2022-04-21</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-none-link" href="/tags/java/" rel="tag">java</a> <a class="article__tag-none-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a>
			</span>
		
	</div>

	

	
		<h2 id="拜占庭容错算法（Byzantine-Generals-Problem）"><a href="#拜占庭容错算法（Byzantine-Generals-Problem）" class="headerlink" title="拜占庭容错算法（Byzantine Generals Problem）"></a>拜占庭容错算法（Byzantine Generals Problem）</h2><h3 id="理想流程"><a href="#理想流程" class="headerlink" title="理想流程"></a>理想流程</h3><p>拜占庭容错算法也叫拜占庭将军问题（Byzantine Generals Problem），由莱斯利-兰波特在论文中所提出的分布式对等网络通信容错问题。</p>
<p>假设一组罗马（拜占庭）将军各率领一直军队 <strong>共同</strong> 围攻一座城市，为简化问题，各种军队的行动策略分别为 <strong>进攻与撤退</strong> 两种。</p>
<p>每个支部队的将军必须通过投票来达成一致策略（所有军队一起进攻或撤退），因为没支部队位置不同，所以需要 <strong>信使</strong> 来进行没支部队的互相联系。</p>
<p>此时每支部队将军可以根据自己的投票和其他将军投票的信息来共同知道所决定的行动策略。</p>
<h3 id="实际问题"><a href="#实际问题" class="headerlink" title="实际问题"></a>实际问题</h3><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>假设在这些8个将军中出现了1叛徒，他们不仅可能向较为糟糕的策略进行投票，还可能选择性的传递投票信息（假设4位将军投的进攻，4位将军投的撤退，那么给进攻的将军说他们投的都是进攻，给投撤退的将军说投的都是撤退）。</p>
<p><strong>那么这样各支军队的一直协调即一致性遭到了破坏</strong></p>
<h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>由于各个将军需要通过 <strong>信使进行通讯</strong>，那么叛徒将军可能通过伪造的信件以及以其他将军的身份发送假的投票。</p>
<p>即使我们保证了所有将军都可靠的情况下，也不能排除信使被敌人截杀或叛变以及替换等情况，因此很闹保证人员的 <strong>可靠性</strong>。：</p>
<h3 id="拜占庭容错"><a href="#拜占庭容错" class="headerlink" title="拜占庭容错"></a>拜占庭容错</h3><p>假设整套体系都按照理想化正常情况下，将军们仍然可以通过 <strong>多数决定战略</strong>，而这将会被称之为 <strong>拜占庭容错</strong></p>
<h2 id="Raft（Reliable-Replicated-Redundant-And-Fault-Tolerant）"><a href="#Raft（Reliable-Replicated-Redundant-And-Fault-Tolerant）" class="headerlink" title="Raft（Reliable,Replicated,Redundant,And Fault-Tolerant）"></a>Raft（Reliable,Replicated,Redundant,And Fault-Tolerant）</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Raft 集群（Reaf cluster）中主要分为 <strong>领袖（leader）、追随者（follower）、候选人（candidate）</strong>。</p>
<p>在一个 Raft 集群中，正常情况下都会有一个领袖，其他都是追随者，领袖会负责所有的外部请求（如果不是领袖机器收到，则请求将会被导到领袖中）。</p>
<p>领袖会有一个固定时间发送消息，即 “心跳（heartbeat）”，让追随者知道领袖还在正常运作。每个追随者都会设计一个计时机制（timeout），当超过一定（通常在 150ms、300ms）时间没有收到领袖的心跳，那么集群将会进入到选举状态。</p>
<h3 id="领导选举"><a href="#领导选举" class="headerlink" title="领导选举"></a>领导选举</h3><p>假设领袖机器死机，那么就需要选择新的领袖。此时进入一个新的任期开始选举，成功当选的领袖开始工作，知道他死了出现故障为止，此时将开启新的一轮选举。</p>
<p>选举是 <strong>候选人</strong> 所发动的，当领导心跳超时的时候追随者就会将自己的任期编号+1，来表示自己参加竞选并投自己一票，并向其他服务器拉票（每台服务器任期只会投一票，<strong>固定给最早拉票追随者</strong>）</p>
<p>如果候选人收到了其他候选人的拉票，且拉票的任期编号大于自己的任期编号，就会人定位落选并成为追随者，以此认为来拉票的候选人为领袖，如果有候选人收到了过半的宣判就当选为新的领袖</p>
<blockquote>
<p>假设在 REST 服务器超时期限过了还没有选出新的领袖时，那么任期将会自动终止，开启新的一场选举。</p>
<blockquote>
<p>Raft 的每台服务器超时期限都是随机的，这也降低了同时竞选的几率，也降低了两个竞选人得票不过半的选举失败几率。</p>
<blockquote>
<p>这场选举也许不是最为公平的，因为当领袖死机的时候，每个已存储指令必定在服务器中已经写入过半。而选举流程则是会让记录较为完整的候选人来胜选，因为在候选人拉票的时候会透漏自己记录的最新信息。</p>
</blockquote>
</blockquote>
</blockquote>
<h3 id="记录复写"><a href="#记录复写" class="headerlink" title="记录复写"></a>记录复写</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210615040340.png"><br>记录复写主要的主角在领袖身上，在 Raft 集群中有一个复写的状态机（State machine）来执行外来的指令，而领袖接受指令来写入记录中。</p>
<p>之后将指令转发给追随者，如果追随者没有反应，领袖会不断的重新发送指令给每个追随者，直到每个追随者将新指令写入记录中为止。</p>
<p>最后领袖收到过半追随者确认写入的信息后，将会将指令视为已存储（committed），追随者发现状态变成已存储，将会在状态机上执行该命令。</p>
<blockquote>
<p>当领袖死机的时候，领袖的某些新指令还没有到写入集群当中，因此会造成集群记录处于不一致的问题，因此为解决此问题：</p>
<blockquote>
<p>新领袖会担有重返一致性的责任，让每个追随者记录都和他一致。他将每个追随者记录进行比较，找出两者一致的最后一个不一致的指令进行删除，将自己之后的指令拷贝个追随者。<br>假设追随者司机，那么给他转发的所有指令都会被回应失败，而发送端会持续重新发送。当这台追随者重新加入集群时，就会收到这些指令并重新回应（已经写入的指令不会被重新写入）。</p>
</blockquote>
</blockquote>
<h2 id="布鲁尔定理（Brewer’s-theorem）"><a href="#布鲁尔定理（Brewer’s-theorem）" class="headerlink" title="布鲁尔定理（Brewer’s theorem）"></a>布鲁尔定理（Brewer’s theorem）</h2><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210615040330.png"></p>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>布鲁尔定理（Brewer’s theorem）也被称之为CAP定理（CAP theorem），主要指出咋分布式系统中的：</p>
<ol>
<li>一致性（Consistency），执行同一个举动</li>
<li>可用性（Availability），每次请求都能获取到正确的响应</li>
<li>分区容错性（Partition tolerance），保证服务宕机时其他服务依然可以正常提供服务（系统中任意信息丢失或失败不会影响系统的继续运作）。</li>
</ol>
<h3 id="三个场景"><a href="#三个场景" class="headerlink" title="三个场景"></a>三个场景</h3><p>通过 CAP 定理，我们无法同时满足一致性、可用性、分区容错性这三个特性，因此我们假设：</p>
<h4 id="CP-（-一致性和分区容错性）"><a href="#CP-（-一致性和分区容错性）" class="headerlink" title="CP （ 一致性和分区容错性）"></a>CP （ 一致性和分区容错性）</h4><p>CP 即 一致性、分区容错性，牺牲掉了可用性保证了一致性，可能会有几个节点不可用，通常适用与银行系统。</p>
<h4 id="AP（可用性和分区容错性）"><a href="#AP（可用性和分区容错性）" class="headerlink" title="AP（可用性和分区容错性）"></a>AP（可用性和分区容错性）</h4><p>AP 是可用性和分区容错性，舍弃掉了一致性，保障服务可用但可能会造成数据的冲突，可适用流量访问大对系统正常提供服务要求较高的系统;</p>
<h4 id="CA（一致性和可用性）"><a href="#CA（一致性和可用性）" class="headerlink" title="CA（一致性和可用性）"></a>CA（一致性和可用性）</h4><p>一旦集群中一台服务无法正常提供服务则会造成当前集群完全崩溃，适用与挑战者。</p>

	

	

</article>




	<article>
	
		<h1><a href="/2022/04/21/java/spring cloud/4.Spring cloud Reactor/">Spring cloud 应用程序分层与响应式</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2022-04-21</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-none-link" href="/tags/java/" rel="tag">java</a> <a class="article__tag-none-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a>
			</span>
		
	</div>

	

	
		<h2 id="MVC（Model-View-Controller）"><a href="#MVC（Model-View-Controller）" class="headerlink" title="MVC（Model-View-Controller）"></a>MVC（Model-View-Controller）</h2><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210610053652.png"><br>MVC（Model View Controller）是在软件工程中较为常见的一种架构模式，无论是 Spring cloud 以及 Spring、Spring boot 基本上我们都介绍过此模型。</p>
<p>如果要简单的理解 MVC 的话，我们可以从上图了解到，首先 <strong>Model</strong> 是拥有对数据直接访问的权利（例如数据库访问）。</p>
<p>而 <strong>Conttroller</strong> 则是可以控制应用程序的流程，并对事件作出响应，这也包括了对 <strong>Model</strong> 的操作。</p>
<p>最后则是 <strong>View</strong> ，他能够显示资料，通常为前端应用。在上图中 Controller 操纵 Model 进行数据的更新或插入，之后交给 View 进行显示给用户。</p>
<p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210610053645.png"></p>
<p>如果说前面我们介绍的都是 MVC 概述，那么通过上图我们可以详细的进行理解。首先浏览器一看是看到的并不是 View，而是 通过 <strong>DispathcherServlet</strong> 来调用视图渲染后返回给浏览器中。这里我们需要注意的是 <strong>DispathcheServlet</strong> 继承于 <strong>HttpServlet</strong> ，主要负责协调和组织不同组件来完成请求并返回响应的工作，他的流程如下：</p>
<ol>
<li>浏览器发送请求，服务器接受请求并转交给 DispatcherServlet 进行处理</li>
<li>DispatcherServlet 匹配在控制器中配置的映射路径，进行下一步处理</li>
<li>View 请求将 Model 和 View 解析成 View，之后调用 render() 方法根据 Model 和 View 中的数据渲染出页面。</li>
</ol>
<h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><p>这与 MVC 的三层架构有很大的关系，所谓三层架构即 表现层（UI）、业务逻辑层（Service）、数据访问层（Dao\Repository）三种，他们分别表示：</p>
<blockquote>
<p>Responsitory 是存取和管理对象，而 Dao 则是存取对象</p>
</blockquote>
<ol>
<li>表现层：<strong>用于展示界面</strong>，接收用户请求并返回数据，为客户端提供应用程序的访问接口（View）</li>
<li>业务逻辑层：也称之为服务层，负责业务逻辑的处理，<strong>主要调用D哦曾对数据进行 CURD 的操作</strong></li>
<li>数据访问层：与数据库进行交互的持久层，被 Service 调用，在 Spring Data JPA 中则由 Hibernate 进行实现。</li>
</ol>
<h2 id="WebFlux"><a href="#WebFlux" class="headerlink" title="WebFlux"></a>WebFlux</h2><blockquote>
<p>反应式是关于异步和事件驱动的非堵塞应用程序，并且需要少量线程进行垂直扩展，而不是水平扩展（集群）。反应式系统具有某些特征，可以使其成为低延迟、高吞度量工作的理想选择。</p>
</blockquote>
<p>WebFlux 是在 Spring Framework 5.0（5.0.0.M5）所引入的一种反应式 Web 框架。WebFlux 可以在资源有限的情况下提高系统的吞度量和垂直扩展，这意味着在同样情况下 WebFlux 的吞吐量明显优于 MVC。</p>
<h3 id="响应式（反应式）与命令式"><a href="#响应式（反应式）与命令式" class="headerlink" title="响应式（反应式）与命令式"></a>响应式（反应式）与命令式</h3><p>为了应对高并发环境下服务端开发，微软提出了一个实现异步编程方案，即 <strong>反应式编程（Reactive Programming）</strong>。其他技术和社区为了跟上脚步，因此向 Netifix 等公司都也提供了类似的技术，这使得 Java 平台也有了能够实现反应式编程的框架</p>
<blockquote>
<p>响应式编程或反应式编程（Reactive programming）是一个面向数据流和 <strong>变化传播</strong> 的声明式编程范式（Declarative programming）。</p>
<blockquote>
<p>响应式编程与命令式编程对立，他的目标是让计算机明白，而非流程，声明式编程不需要告诉电脑问题，<strong>即告诉结果，让机器自行解决</strong></p>
<blockquote>
<blockquote>
<p>而响应式编程则是是意味着式子 <code>a=b+c</code>，这意味着 a 是由 b 和 c 计算而出，如果后续有变化会影响到 a 的值，这也是 <strong>即告诉结果，让机器自行解决</strong> </p>
</blockquote>
<p>命令式编程或指令式编程（Inperative programming），<strong>详细命令机器去处理一种事情而达到你想要的结果</strong>。<br>变化传递我们可以理解为在命令式变成中，假设式子为 <code>a=b+c</code> 那么 a 的值就来自 b和c计算出的，如果后续有变化不会影响到a的值，这也是为什么他是 <strong>细命令机器去处理一种事情而达到你想要的结果</strong></p>
</blockquote>
</blockquote>
</blockquote>
<p>Spring WebFlux 是一个从头开始构建的非堵塞Web框架，可利用多核下一代处理器并处理大量并发。而 WebFlux 与 Spring MVC 数据流的选择也各不相同，前者是 <strong>Reactive Streames</strong>，后者则是 <strong>Servlet API</strong>。</p>
<p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210610053635.png"><br>自然而然，既然 WebFlux 是用的是响应式数据流，而Spring MVC 选择的是 命令式数据流，自然而然 WebFlux 会更快。我认为上图很好的诠释了这一点，Spring MVC 是一个 <strong>响应 -&gt; 准备数据 -&gt; 返回数据</strong> 的一个过程。而 WebFlux 则是 <strong>响应 -&gt; 返回数据 -&gt; 开启一个新的 Work 线程进行准备 -&gt; Work 线程完成工作 -&gt; 返回结果</strong> 从而让对方觉得 WebFlux 会更快的一点。</p>
<h3 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h3><p>Peactor 框架由 Pivotal 基于 <strong>反应式编程（Reactive Programming）</strong> 思想进行实现，符合反应式编程的规范。</p>
<h4 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h4><p>响应式编程（Reactive Programming）是一种非堵塞且事件驱动数据的开发方案，使用函数式编程的概念来操作数据流。</p>
<blockquote>
<p>函数式编程是一种编程方式，将计算机的运算视为函数计算，如何直接和生动形象的表现出函数式编程的特点呢，那么下面的表达式就非常的清晰</p>
<blockquote>
<p><strong>过程式编程：</strong> var a &#x3D; 1 + 2;<br><strong>函数式编程：</strong> var result &#x3D; subtract(multiply(add(1,2), 3), 4);</p>
</blockquote>
<p>其实函数式变成并没有什么特殊，他其实就是将一数复制给变量或者一个数组中，就这个意思。<br>函数变成最主要的是λ演算 (Iambda calculus)，而λ演算可以 <strong>接受函数党组输出（参数）和输出（返回值）</strong>，相比过程化编程相比，<strong>函数式编程里的函数可以随时调用</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>事件</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>包含元素信息</td>
<td>onNext()</td>
</tr>
<tr>
<td>序列结束消息</td>
<td>onComplete()</td>
</tr>
<tr>
<td>序列出错消息</td>
<td>onError()</td>
</tr>
</tbody></table>
<p>这是通知与订阅者对应的方法，但如果我们继续眼神可以了解到背压机制（与本文有关）：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>Iterable 迭代模式 (拉\pull)</th>
<th>Observable 观察模式(推\push)</th>
</tr>
</thead>
<tbody><tr>
<td>获取数据</td>
<td>T next()</td>
<td>onNext()</td>
</tr>
<tr>
<td>处理完成</td>
<td>hasNext()</td>
<td>onCompleted()</td>
</tr>
<tr>
<td>发现异常</td>
<td>throws Exception</td>
<td>onError()</td>
</tr>
</tbody></table>
<blockquote>
<p>1.<strong>事件发布者（Publisher）</strong> 主动推送数据给 <strong>订阅者（Subscriber）</strong>，出发 onNext() 方法;<br>2.<strong>事件发布者</strong>发生异常，则触发 <strong>订阅者</strong> 的 onError() 方法进行异常捕获处理<br>3.<strong>事件发布者</strong>每次推送都触发一次 onNext() 方法，当所有推送无异常时， onCompleted() 方法在在最后触发一次。</p>
<p>我们可以从被订阅者和订阅者理解为服务提供者和服务消费者。</p>
</blockquote>
<p>如果 被订阅者发布的消息太快了，超过了订阅者的处理速度，那么这个时候就需要通过 <strong>背压机制（Backpressure），使得订阅者能够控制消费消息的速度。</strong></p>
<p>实际上除了 <strong>迭代模式 (lterable)</strong> 其他的都是我们 <strong>响应式编程API的使用方式</strong>，实际上激素和观察者模式(Observable)的扩展。</p>
<h4 id="Reactive-Streams"><a href="#Reactive-Streams" class="headerlink" title="Reactive Streams"></a>Reactive Streams</h4><blockquote>
<p>他由 Netifix，TypeSafe、Pivatol共同制定，这是 Java 平台上 RxJava、Scala、Akka、Spring、Reactor 等项目的主要维护者所共同发起的。</p>
</blockquote>
<p>反应式流（Reactive Streams）是一项倡议，主要用于反应式编程相关的规范以及接口提供标准。</p>
<p>他主要有四个组件构成，分别为发布者、订阅者、订阅、处理器等。除此还有三个接口最为主要：</p>
<ol>
<li>Publisher（事件发布者）</li>
<li>Subscriber（订阅者）</li>
<li>Subcription（订阅）</li>
</ol>
<h4 id="Mono-与-Flux"><a href="#Mono-与-Flux" class="headerlink" title="Mono 与  Flux"></a>Mono 与  Flux</h4><p>Mono 与 Flux 都是事件的发布者，也是 Reactor 的核心类：</p>
<ul>
<li>Mono<ul>
<li>实现了 org.reactivestreams.<strong>Publisher</strong> 接口，用于返回单个数据</li>
</ul>
</li>
<li>Flux<ul>
<li>同样实现了 org.reactivestreams.<strong>Publisher</strong> 接口，用于返回多个数据。</li>
</ul>
</li>
</ul>
<p>如果根据 ID 查询某个 User 对象，那么返回的肯定是单个数据，那么就需要使用 <code>Mono&lt;User&gt;</code></p>
<p>但是如果要获取所有 User，则返回的是多个数据，需要使用 <code>Flux&lt;User&gt;</code>。</p>
<p>需要注意的是 Mono 与 Flux 之间可以 <strong>互相转换</strong>，对一个 Flux 序列进行技术操作，得到的结果是一个 <code>Mono&lt;Long&gt;</code> 对象，将多个 Mono 序列合并在一起，则得到的是 Flux 对象。</p>

	

	

</article>




	<article>
	
		<h1><a href="/2022/04/21/java/spring cloud/3.Spring cloud Eureka/">Spring cloud Eureka</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2022-04-21</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-none-link" href="/tags/java/" rel="tag">java</a> <a class="article__tag-none-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a>
			</span>
		
	</div>

	

	
		<p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210525030152.png"></p>
<p>本文将会通过 Eureka 来进行服务中心的治理，并实现出 一个 <strong>服务中心集群（Eureka Server ……）</strong>，以及 <strong>服务提供者集群（Service Provider ……）</strong> 还有一个 <strong>服务提供者消费者（Service Consumer）</strong> 。之后通过 <strong>服务中心</strong> 内的 <strong>Eureka</strong> 来进行服务治理，让 <strong>服务消费者（Service Consumer） 调用 服务提供者（Service Provider）</strong> 来提供服务。</p>
<p>我们首先使用 Eureka 来实现出一个 <strong>服务中心（Eureka Server）</strong> 集群，之后通过 Eureaka 所 <strong>提供的服务注册（Service Register）</strong> 功能来注册 <strong>服务提供者（Service Provider）</strong>，来实现服务提供者集群。</p>
<p>在此后<strong>服务消费者（Service Consumer）</strong> 使用 Eureka 所提供的 <strong>服务注册功能根据服务提供者（Service Provider）</strong> 所注册的名称来调用客户端 <strong>Feign</strong> 来消费 <strong>服务提供者所提供的接口</strong>。</p>
<p>Eureka 是 Netflix 全家桶内项目，他在毕马威在2019年10月所发布的 《颠覆性公司和商业模式》报告中与阿里巴巴分别排名第三，而 Netflix 排名第六位，百度、腾讯分别排名十一和十二位。</p>
<p>虽然 Netlix 排名不如 Alibaba，但他对 Spring cloud 的贡献要早于 Alibaba，因此Netflix 公司所开源的各种项目所组成微服务的核心也不足为奇。</p>
<p>表现层状态转换（Representational State Transfer，REST）由 Roy Thomas Fielding 于 2000年在博士论文中所提出的WWW软件架构风格，目的是放百年在不同软件或程序在网络中相互传递信息，而 Eureka 则是这些项目内基于 REST 服务，主要包含了 <strong>服务注册与服务发现功能</strong>。</p>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210526225911.png"></p>
<h3 id="Spring-Assistant"><a href="#Spring-Assistant" class="headerlink" title="Spring Assistant"></a>Spring Assistant</h3><blockquote>
<p> 这从 IDEA 2018 就停止更新了</p>
</blockquote>
<p>通过 Spring Assistant 根据自身环境进行选择，当进入选择版本和依赖时，我们需要选择 <strong>Spring Cloud Discover -&gt; Eureka Server</strong>。</p>
<h3 id="Spring-Initializr"><a href="#Spring-Initializr" class="headerlink" title="Spring Initializr"></a>Spring Initializr</h3><p>或者说我们直接通过 IDEA 自带的 <strong>Spring Initializr</strong>，之后选择 <strong>Spring Cloud Discovery -&gt; Eureka Server</strong>。当我们构建完成后，肯对会出现一大堆 maven 项目依赖的问题，因此我们需要在 <strong>Setting -&gt; Build, Execution, Deployment -&gt; Build Tools -&gt; Maven</strong> 下修改 <strong>User settings file</strong> 所填写的 <code>settings.xml</code> 文件，并写入下述信息，来设置 Alibaba 镜像：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>uk<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://uk.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>CN<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>OSChina Central<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.oschina.net/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>internal nexus repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="服务中心"><a href="#服务中心" class="headerlink" title="服务中心"></a>服务中心</h2><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210527035316.png"><br>我们所实现的是 <strong>服务中心集群</strong>，和普通的单点服务中心不一样的是，我们可以保障在系统崩溃时，可以维持系统的 <strong>更高的可用性</strong>，所以使用服务中心集群（虽然是服务中心集群，但依然可以通过本文来实现单点服务中心）。</p>
<h3 id="Eureka-Server-demo"><a href="#Eureka-Server-demo" class="headerlink" title="Eureka Server demo"></a>Eureka Server demo</h3><p>我们可以通过一个标准的 Eureka 模板来进行参考，并通过下述模板来进行修改来实现出我们的 <strong>服务中心集群</strong> ，需要注意的是下述code不需要执行（因为你就算执行了实现的也是单点服务中心）：</p>
<h4 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h4><blockquote>
<p>src&#x2F;main&#x2F;resources&#x2F;application.properties</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 应用名称</span><br><span class="line">spring.application.name=Discovery Server</span><br><span class="line"></span><br><span class="line"># Spring 应用端口</span><br><span class="line">server.port=8000</span><br><span class="line"></span><br><span class="line"># 节点名称</span><br><span class="line">eureka.instance.hostname=eureka-server.com</span><br><span class="line"></span><br><span class="line"># 是否注册到 Eureka Server (默认 true）</span><br><span class="line">eureka.client.register-with-eureka=false</span><br><span class="line"></span><br><span class="line"># 是否注册到 Eureka Server 获取注册信息 （默认 true）</span><br><span class="line">eureka.client.fetch-registry=false</span><br><span class="line"></span><br><span class="line"># 设置 Eureka Server 交互地址，查询服务和注册服务进行使用（多个以 “,” 分割）</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br></pre></td></tr></table></figure>

<h4 id="DemoApplication"><a href="#DemoApplication" class="headerlink" title="DemoApplication"></a>DemoApplication</h4><blockquote>
<p>src&#x2F;main&#x2F;java&#x2F;com&#x2F;example&#x2F;demo&#x2F;DemoApplication.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hosts"><a href="#hosts" class="headerlink" title="hosts"></a>hosts</h4><p>为了让效果更加的接近真实环境下多台服务器内应用协同服务，所以我们可以通过添加几个 <strong>虚拟地址（DNS）</strong> 来创建一个只有本地可以访问的 URL，来进行演示。</p>
<p>在 Windows 环境下，我们需要修改 <code>C:\Windows\System32\drivers\etc\hosts</code> 文件，并添加：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1      abc.com</span><br></pre></td></tr></table></figure>

<p>而本文作者使用的是 debian 环境，即 Linux 系统下则需要简单的修改 <code>/etc/hosts</code> 文件即可，并添加：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1	eureka-server.com</span><br><span class="line">127.0.0.1	eureka-server-1.com</span><br><span class="line">127.0.0.1	eureka-server-2.com</span><br><span class="line">127.0.0.1   eureka-server-3.com</span><br></pre></td></tr></table></figure>

<p>为了验证其是否生效，可以直接通过 <code>ping xxx.com</code> 进行查看。</p>
<h4 id="Jar-Run"><a href="#Jar-Run" class="headerlink" title="Jar Run"></a>Jar Run</h4><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210527035329.png"></p>
<p>之后我们分别在 <strong>eureka-server-1、eureka-server-2、eureka-server-3</strong> 项目下按照流程点击 maven 侧栏下的 <code>clean、package</code>等命令，以此来代替 mvn 执行 <code>mvn clean | mvn package</code>命令。</p>
<p>当的包项目为 jar 后，分别进入 <strong>eureka-server-1、2、3</strong> 内该 jar 包所在位置，并指定根据之前所在 hosts 文件下设置的DNS名称运行项目（有多少服务集群搞多少个）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar demo-0.0.1-SNAPSHOT.jar --spring.profiles.active=eureka-server.com</span><br></pre></td></tr></table></figure>

<p>之后进入到<code>http://eureka-server.com:8000/</code> 即可访问 Eureka 所提供的信息面板中。</p>
<h3 id="eureka-server-1"><a href="#eureka-server-1" class="headerlink" title="eureka-server-1"></a>eureka-server-1</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210527035343.png"></p>
<blockquote>
<p>如果你理解上述的 Eureka Server demo 的配置并结合下述 eureka-server-1~3 所部署的服务中心集群在 Eureka 控制面板和上图基本相似。</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">server-clustered</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Spring 应用端口</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8001</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 节点名称</span></span><br><span class="line"><span class="attr">eureka.instance.hostname</span>=<span class="string">eureka-server-1.com</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 是否注册到 Eureka Server (默认 true）</span></span><br><span class="line"><span class="attr">eureka.client.register-with-eureka</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 是否注册到 Eureka Server 获取注册信息 （默认 true）</span></span><br><span class="line"><span class="attr">eureka.client.fetch-registry</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 设置 Eureka Server 交互地址，查询服务和注册服务进行使用（多个以 “,” 分割）</span></span><br><span class="line"><span class="attr">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://eureka-server-2.com:8002/eureka/,http://eureka-server-3.com:8003/eureka/</span></span><br></pre></td></tr></table></figure>

<h3 id="eureka-server-2"><a href="#eureka-server-2" class="headerlink" title="eureka-server-2"></a>eureka-server-2</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">server-clustered</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Spring 应用端口</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8002</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 节点名称</span></span><br><span class="line"><span class="attr">eureka.instance.hostname</span>=<span class="string">eureka-server-2.com</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 是否注册到 Eureka Server (默认 true）</span></span><br><span class="line"><span class="attr">eureka.client.register-with-eureka</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 是否注册到 Eureka Server 获取注册信息 （默认 true）</span></span><br><span class="line"><span class="attr">eureka.client.fetch-registry</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 设置 Eureka Server 交互地址，查询服务和注册服务进行使用（多个以 “,” 分割）</span></span><br><span class="line"><span class="attr">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://eureka-server-1.com:8001/eureka/,http://eureka-server-3.com:8003/eureka/</span></span><br></pre></td></tr></table></figure>

<h3 id="eureka-server-3"><a href="#eureka-server-3" class="headerlink" title="eureka-server-3"></a>eureka-server-3</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">server-clustered</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Spring 应用端口</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8003</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 节点名称</span></span><br><span class="line"><span class="attr">eureka.instance.hostname</span>=<span class="string">eureka-server-3.com</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 是否注册到 Eureka Server (默认 true）</span></span><br><span class="line"><span class="attr">eureka.client.register-with-eureka</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 是否注册到 Eureka Server 获取注册信息 （默认 true）</span></span><br><span class="line"><span class="attr">eureka.client.fetch-registry</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 设置 Eureka Server 交互地址，查询服务和注册服务进行使用（多个以 “,” 分割）</span></span><br><span class="line"><span class="attr">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://eureka-server-1.com:8001/eureka/,http://eureka-server-2.com:8002/eureka/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h2><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210528034643.png"><br>服务提供者（Service provider），我们可以理解为是通过服务中心进行注册，之后为 <strong>服务消费者</strong> 来提供服务的。我们可以从服务中心，来控制、管理整个微服务的运行、连接状态等。</p>
<h3 id="Eureka-Provide-demo"><a href="#Eureka-Provide-demo" class="headerlink" title="Eureka Provide demo"></a>Eureka Provide demo</h3><h4 id="DemoApplication-1"><a href="#DemoApplication-1" class="headerlink" title="DemoApplication"></a>DemoApplication</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过根据之前一样的项目依赖，选择 Eureka Server 即可，进入项目后在启动类中加入 <code>@EnableEurekaClient</code> 注解，来启用其 Eureka 注册和发现功能。</p>
<h4 id="application-properties-1"><a href="#application-properties-1" class="headerlink" title="application.properties"></a>application.properties</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">server-provide</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8000</span></span><br><span class="line"><span class="attr">provider.name</span>=<span class="string">provider0</span></span><br><span class="line"><span class="attr">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://eureka-server-3.com:8003/eureka/,http://eureka-server-2.com:8002/eureka/,http://eureka-server-1.com:8001/eureka/</span></span><br></pre></td></tr></table></figure>

<p>之后我们来设置名称以及控制器需要获取到的信息进行配置，之后通过 <code>eureka.client.serviceUrl.defaultZone</code>来加入服务中心。</p>
<h4 id="HelloController"><a href="#HelloController" class="headerlink" title="HelloController"></a>HelloController</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;provider.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/home&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;provider:&quot;</span> + name + <span class="string">&quot;port:&quot;</span> + port;</span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制器的主要用途是来提供接口让 <strong>服务消费者</strong> 进行获取的，通过<code>application.properties</code>配置文件内相应内容并根据其<code>@Vlue</code>注解以及 <code>@RestController</code>处理HTTP请求，如果你不觉得麻烦可以用下述两个注解代替：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br></pre></td></tr></table></figure>

<h4 id="Actuator-info"><a href="#Actuator-info" class="headerlink" title="Actuator info"></a>Actuator info</h4><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210528033455.png"><br>Eureka 在其信息面板中 Instances currently registered with Eureka （目前在Eureka 注册的实例）一览中的 Status（状态）下。为开发者提供了一个便捷查询的入口，即 <code>UP (1) - 192.168.43.65:server-provide:8000</code> &#x3D;&gt; <a target="_blank" rel="noopener" href="http://192.168.43.65:8000/actuator/info">http://192.168.43.65:8000/actuator/info</a> 这是服务提供者的当前在服务中心的链接状态。</p>
<p>当我们点击跳转时，是可以根据其 <code>pom.xml</code> 以及 <code>application.properties</code> 文件内的配置信息单独写入其 JSON 数据的，虽然 Eureka 默认的为 <code>&#123;&#125;</code>。</p>
<p>修改添加后结果如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;app&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eureka-cloud-8000&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;company&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jiangxue.org.cn&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;application&quot;</span><span class="punctuation">:</span> <span class="string">&quot;server-provide&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8000&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们需要修改其 <strong>application.properties</strong> 即 Spring 的全局配置文件：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">server-provide</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8000</span></span><br><span class="line"><span class="attr">provider.name</span>=<span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">info.app.name</span>=<span class="string">eureka-cloud-8000</span></span><br><span class="line"><span class="attr">info.company.name</span>=<span class="string">jiangxue.org.cn</span></span><br><span class="line"><span class="attr">info.build.application</span>=<span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="attr">info.build.port</span>=<span class="string">$&#123;server.port&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://eureka-server-3.com:8003/eureka/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210528033534.png"><br>之后我们还需要修改 <strong>pom.xml</strong> 配置文件信息，在 <code>&lt;build&gt;&lt;/build&gt;</code>元素中的 <code>&lt;plugins&gt;</code> 上方，加入 <code>&lt;finalName&gt;</code>信息：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>之后我们可以选择直接在 IDEA 里面运行或通过 jar 包方式运行（<strong>虽然是本地环境但还是要整出几十台服务器协同的效果</strong>）</p>
</blockquote>
<h4 id="Jar-run"><a href="#Jar-run" class="headerlink" title="Jar run"></a>Jar run</h4><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210528033544.png"><br>当全部运行完之后，我们将会有三台服务中心集群，以及两台服务提供集群，通过访问我们服务提供集群的控制器即 <a target="_blank" rel="noopener" href="http://192.168.43.65:8010/hey">http://192.168.43.65:8010/hey</a> 都可以正确访问控制器内容时，即可以正常提供服务。</p>
<h3 id="eureka-provide-1"><a href="#eureka-provide-1" class="headerlink" title="eureka-provide-1"></a>eureka-provide-1</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">server-provide</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8010</span></span><br><span class="line"><span class="attr">provider.name</span>=<span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">info.app.name</span>=<span class="string">eureka-cloud-$&#123;server.port&#125;</span></span><br><span class="line"><span class="attr">info.company.name</span>=<span class="string">jiangxue.org.cn</span></span><br><span class="line"><span class="attr">info.build.application</span>=<span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="attr">info.build.port</span>=<span class="string">$&#123;server.port&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://eureka-server-3.com:8003/eureka/,http://eureka-server-2.com:8002/eureka/,http://eureka-server-1.com:8001/eureka/</span></span><br></pre></td></tr></table></figure>

<h3 id="eureka-provide-2"><a href="#eureka-provide-2" class="headerlink" title="eureka-provide-2"></a>eureka-provide-2</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">server-provide</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8011</span></span><br><span class="line"><span class="attr">provider.name</span>=<span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">info.app.name</span>=<span class="string">eureka-cloud-$&#123;server.port&#125;</span></span><br><span class="line"><span class="attr">info.company.name</span>=<span class="string">jiangxue.org.cn</span></span><br><span class="line"><span class="attr">info.build.application</span>=<span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="attr">info.build.port</span>=<span class="string">$&#123;server.port&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://eureka-server-3.com:8003/eureka/,http://eureka-server-2.com:8002/eureka/,http://eureka-server-1.com:8001/eureka/</span></span><br></pre></td></tr></table></figure>

<h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h2><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210528095543.png"></p>
<p>服务消费者主要通过使用 <strong>Feign</strong> 来进行实现，Feign 由 Retrofit、JAXRS-2.0 和 WebSocet 所启发，主要用于 Java 到 HTPP 客户端绑定器。因此我们将会通过引入 Feign 依赖来实现服务消费者。</p>
<p>在新建项目时，我们需要注意，需要在 <strong>选择依存关系内选择</strong> Spring Web、Eureka Discovery Client。当然之前的服务提供者也可以这样选择，但为了更加方便我们通过选择 <strong>Eureka Server</strong> 单个依存关系也可以实现。</p>
<h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210528093919.png"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加 spring-cloud-starter-openfeign maven 依赖后可能会报错，此时我们只需要通过点击 Reload ALL Maven Projects 按钮来 <strong>重新加载所有 Maven 项目</strong>。</p>
<h3 id="application-properties-2"><a href="#application-properties-2" class="headerlink" title="application.properties"></a>application.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">service-consumer</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">9000</span></span><br><span class="line"><span class="attr">eureka.client.register-with-eureka</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://eureka-server-3.com:8003/eureka/,http://eureka-server-2.com:8002/eureka/,http://eureka-server-1.com:8001/eureka/</span></span><br></pre></td></tr></table></figure>

<h3 id="DemoApplication-2"><a href="#DemoApplication-2" class="headerlink" title="DemoApplication"></a>DemoApplication</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过使用 <code>@EnableDiscoveryClients</code>来启动客户端的服务注册和发现功能，并以 <code>@enableFeignClients</code> 注解来实现远程服务调用。</p>
<h3 id="MyFeignClient-interface"><a href="#MyFeignClient-interface" class="headerlink" title="MyFeignClient interface"></a>MyFeignClient interface</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;server-provide&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFeignClient</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/hey&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，我们在此处的方法必须与服务提供者（即服务提供者 Controller）的方法一致</p>
</blockquote>
<p>之后我们需要定义一个接口，并使用 <code>@FeignClient</code> 注解来通过 <strong>name</strong> 值在服务中心进行寻找并连接。在这里我们的服务提供者集群在服务中心所注册的名称是 <strong>server-provide</strong>。</p>
<h3 id="ConsumerController"><a href="#ConsumerController" class="headerlink" title="ConsumerController"></a>ConsumerController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.MyFeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyFeignClient myFeignClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hey&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> myFeignClient.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210528094005.gif"><br>最终我们将服务中心集群、服务提供者集群开起来，以及在 IDEA 中启动服务消费者。之后通过访问 <a target="_blank" rel="noopener" href="http://localhost:9000/hey">http://localhost:9000/hey</a> 刷新两次看看。</p>
<p>如果端口值从 <strong>8010～8011</strong> 之间不断调换。那么我们通过 Eureka 来进行服务治理所实现的微服务架构完成。</p>

	

	

</article>




	<article>
	
		<h1><a href="/2022/04/21/java/spring cloud/2.Spring cloud 概述/">Spring cloud 概述</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2022-04-21</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-none-link" href="/tags/java/" rel="tag">java</a> <a class="article__tag-none-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a>
			</span>
		
	</div>

	

	
		<p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210525030152.png"></p>
<p>Spring cloud 是一个基于 Spring boot 的一个快速开发的微服务框架，有一句话是 <strong>小项目用 spring boot，大项目用 spring cloud</strong>，他主要九个非常重要且显著的特征。</p>
<h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>在介绍Spring cloud 各类特性和主要项目以及开源生态之前，我们需要了解表现层状态转换（REST，Representational State Transfer），由 Roy T. Fielding博士于 2000年在博士论文中提出。其提供出来的主要是一种互联网软件 <strong>设计风格</strong>，目的是方便软件或程序在互联网中互相传递信息。</p>
<p>在 Roy 的博士论文中我们可以看到其清楚的定义了下列六种知道原则，也就是我们将满足 REST 六种指导原则的风格称之为 RESTful：</p>
<ol>
<li>客户端-服务器（Client-Server）</li>
<li>无状态（Stateless）</li>
<li>缓存 (Cache)</li>
<li>统一接口（Uniform Interface）</li>
<li>分层系统（Layered System）</li>
<li>按需编码（Code On Demand）</li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a></p>
</blockquote>
<p>在这之后根据这篇论文进行了详细和系统的完善，使得更加具有了可读性：<a target="_blank" rel="noopener" href="https://restfulapi.net/">https://restfulapi.net/</a></p>
<h3 id="客户端-服务器（Client-Server）"><a href="#客户端-服务器（Client-Server）" class="headerlink" title="客户端-服务器（Client-Server）"></a>客户端-服务器（Client-Server）</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210608033023.png"><br>在REST中，被第一个添加的则是客户端和服务器之间的架构风格约束，而他的关注点是客户端-服务器约束背后的原则。<strong>通过将用户界面与存数据存储问题进行分开， 这提高了用户界面跨平台的移植性以及简化了服务器组建，提高了扩展性。</strong></p>
<h3 id="无状态（Stateless）"><a href="#无状态（Stateless）" class="headerlink" title="无状态（Stateless）"></a>无状态（Stateless）</h3><p>根据客户端和-服务器通信中，我们假设通信本质是无状态（Stateless）的，即客户端到服务器的每个请求都不会存储上下文（会话完全保留在客户机上）。</p>
<p>而这些约束改善了 可见性、可靠性、可扩展性等，其中最为明显的则是可扩展性。</p>
<blockquote>
<p>This constraint induces the properties of visibility, reliability, and scalability. Visibility is improved because a monitoring system does not have to look beyond a single request datum in order to determine the full nature of the request. Reliability is improved because it eases the task of recovering from partial failures. Scalability is improved because not having to store state between requests allows the server component to quickly free resources, and further simplifies implementation because the server doesn’t have to manage resource usage across requests.</p>
</blockquote>
<p>他的缺点是可能会增加一系列请求中发送的重复数据，从而降低网络性能等方面。</p>
<h3 id="缓存-Cache"><a href="#缓存-Cache" class="headerlink" title="缓存 (Cache)"></a>缓存 (Cache)</h3><p>缓存存在的意义则是在 REST 中提高网络效率，缓存主要被约束为请求的响应中内的数据隐式（或显示）标记为 <strong>可缓存或不可缓存</strong>。</p>
<p>如果是可缓存的，则在客户端缓存有权为以后同样效果的请求重新应用该响应数据。</p>
<h3 id="统一接口（Uniform-Interface）"><a href="#统一接口（Uniform-Interface）" class="headerlink" title="统一接口（Uniform Interface）"></a>统一接口（Uniform Interface）</h3><p>在 REST 架构风格中与其他类似架构风格有明显区分的就是组件之间的统一接口，他简化了整个系统架构并提高了交互的可见性。</p>
<p>为了实现和获得统一接口，需要多个架构约束来指导组件的行为，而 REST 则是由四个接口约束定义：</p>
<h4 id="资源识别-identification-of-resources"><a href="#资源识别-identification-of-resources" class="headerlink" title="资源识别 (identification of resources)"></a>资源识别 (identification of resources)</h4><p>请求中包含了各种独立资源的标识，如 Url等。除此之外还可以将自身的数据库信息以 HTML、XML、JSON等方式发送给客户端。</p>
<h4 id="操纵资源-manipulation-of-resources-through-representations"><a href="#操纵资源-manipulation-of-resources-through-representations" class="headerlink" title="操纵资源 ( manipulation of resources through representations)"></a>操纵资源 ( manipulation of resources through representations)</h4><p>当客户端拥有资源标识后，就可以根据足够的信息删除这个资源</p>
<h4 id="描述信息-self-descriptive-messages"><a href="#描述信息-self-descriptive-messages" class="headerlink" title="描述信息 (self-descriptive messages)"></a>描述信息 (self-descriptive messages)</h4><p>每个消息都包含了可以描述来如何处理这个信息的方式，如媒体类型（media type）以及最后修改时间 (modified time)</p>
<h3 id="分层系统（Layered-System）"><a href="#分层系统（Layered-System）" class="headerlink" title="分层系统（Layered System）"></a>分层系统（Layered System）</h3><p><img src="https://www.ics.uci.edu/~fielding/pubs/dissertation/layered_uccss.gif"><br>分层系统的样式允许通过约束组件行为为使得每个组件 <strong>”不能“</strong> 看到与其直接交互的直接层之外的其他层，将架构由分层组成。2</p>
<blockquote>
<p>需要注意的是很多文档都将  用超媒体驱动应用状态，“hypermedia as the engine of application state” 夹在里面，实际上他的意思为 ”超媒体 <strong>作为</strong> 应用程序状态引擎“</p>
</blockquote>
<h3 id="按需编码（Code-On-Demand）"><a href="#按需编码（Code-On-Demand）" class="headerlink" title="按需编码（Code On Demand）"></a>按需编码（Code On Demand）</h3><p>按照 Roy 论文来理解，按需编码在 REST 其实是一个可选约束，并提供了一个非常不错的例子：</p>
<blockquote>
<p>例如，如果已知组织内的所有客户端软件都支持 Java，则可以构建该组织内的服务，以便通过下载的Java 类来获得增强功能的好处。</p>
<p>但问题在于组织的防火墙可能会组织外部资源传输到 Java 小程序，对于 Web 的其他部分，某些客户端可能不支持该代码。</p>
</blockquote>
<p>而按需编码所提供的 可选约束就允许我们设计一个在一般情况下支持所需行为的架构。</p>
<p>当然这是一种理解，而第二种理解就偏向与实际，大多数形式下返回的资源都以 XML或JSON表示，但是需要的时候，我们可以自由的返回可执行代码。</p>
<p>来支持自己应用程序的部分，根据按需编码的约束这是允许的，因为这属于 ”可选约束“。</p>
<blockquote>
<p>应用与 Web 服务</p>
<p>我们可以根据 REST 的设计风格为 Web API 进行设计，符合其统一接口约束即可以被称之为 ”RESTful API“，他主要就是以统一接口的三个约束原则而定义的。</p>
<p><strong>资源识别</strong> 我们可以理解为 资源地址的 URL，如 <code>http://example.com/resources</code><br><strong>传输的资源（描述信息）</strong>  Web服务接受与返回的媒体类型，如 <code>JSON、XML</code>等<br>而对 <strong>操纵资源</strong>则是所支持的一系列请求方法，如 POST、GET、PUT、DELETE 等。</p>
<p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210608033034.png"></p>
<p>如果你说你要实现一个 REST设计风格的 RESTful API，则可以参照下述例子：</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 所有文章</span><br><span class="line">GET http://www.example.com/list</span><br><span class="line"></span><br><span class="line">2. 阅读某篇文章</span><br><span class="line">GET http://www.example.com/list/&#123;id&#125;</span><br><span class="line"></span><br><span class="line">3. 发布文章</span><br><span class="line">POST http://www.example.com/list/release</span><br></pre></td></tr></table></figure>

<blockquote>
<p>推荐阅读 <a target="_blank" rel="noopener" href="https://restfulapi.net/resource-naming/">https://restfulapi.net/resource-naming/</a></p>
</blockquote>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><blockquote>
<p>Spring cloud 很早就提供了下述特征的实现，但由于早期相关代码和介绍存在与 Spring cloud 的子项目 Spring Cloud Cluster 中，到最后被迁移至 Spring Integration 中。</p>
<p>这也是为什么 Spring cloud 在官方文档中说了自己的 xx 特征，但又很难找到相关文档的原因，这是因为人家早就把代码和文档迁移到了 Spring Integration 中了。</p>
</blockquote>
<h3 id="分布式-版本化管理（Distributed-x2F-versioned-configuration）"><a href="#分布式-版本化管理（Distributed-x2F-versioned-configuration）" class="headerlink" title="分布式\版本化管理（Distributed&#x2F;versioned configuration）"></a>分布式\版本化管理（Distributed&#x2F;versioned configuration）</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210525113032.png"></p>
<blockquote>
<p>Spring cloud Config 与 Spring cloud Bus 经常一起搭配使用，这可以让他无需重新启动服务可以刷新配置文件的信息。</p>
</blockquote>
<p>通过 Spring Cloud Config 来统一管理服务配置，可以将所有服务的配置文件 <strong>放置在本地仓库或者远程仓库中</strong>。让Spring cloud config 配置中心来负责读取仓库的配置文件，而客户端（服务）从配置中心读取配置。</p>
<h3 id="服务注册和发现（Service-registration-and-discovery）"><a href="#服务注册和发现（Service-registration-and-discovery）" class="headerlink" title="服务注册和发现（Service registration and discovery）"></a>服务注册和发现（Service registration and discovery）</h3><p>服务治理组件主要由 Eurake、Consul 等进行，他在此相当于交易的信息员，可以 <strong>发现</strong> 服务提供者（Service Provider），还可以将自己注册到 <strong>服务中心（Eureka Server）中</strong></p>
<h3 id="路由（Routing）"><a href="#路由（Routing）" class="headerlink" title="路由（Routing）"></a>路由（Routing）</h3><p>通过智能路由网管组件 Zuul、Spring Cloud Gateway 来实现智能路由和请求过滤功能。内部服务接口通过网关统一对外暴露，来避免内部服务敏感信息信息在未经授权情况下对外暴露。</p>
<h3 id="服务到服务的通信（Service-to-service-calls）"><a href="#服务到服务的通信（Service-to-service-calls）" class="headerlink" title="服务到服务的通信（Service to service calls）"></a>服务到服务的通信（Service to service calls）</h3><blockquote>
<p>Service to service calls 在官方文档中并没有进行概述，所以本文仅是个人观点。</p>
</blockquote>
<p>Spring cloud 中服务到服务的通信组要通过 Eureka 组件来调用微服务的顺序。</p>
<h3 id="负载均衡（Load-balancing）"><a href="#负载均衡（Load-balancing）" class="headerlink" title="负载均衡（Load balancing）"></a>负载均衡（Load balancing）</h3><p>负载均衡主要可以通过 Feign、Ribbon来实现负载均衡。</p>
<h3 id="断路器（Circuit-Breakers）"><a href="#断路器（Circuit-Breakers）" class="headerlink" title="断路器（Circuit Breakers）"></a>断路器（Circuit Breakers）</h3><p>断路器使用服务容错组件 Hystrix、Resilience4j来控制服务的API接口荣段，以实现故障转移、服务限流、服务降级等功能。防止微服务系统发生 <strong>雪崩效应</strong>，可以使用 Hystrix Dashboard 组件监控 <strong>单个融断状态</strong>，使用 Hystrix Turbine 组件监控 <strong>多个服务的融断状态</strong>。</p>
<h3 id="全局锁（Global-locks）"><a href="#全局锁（Global-locks）" class="headerlink" title="全局锁（Global locks）"></a>全局锁（Global locks）</h3><p>也许可以通过 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud-samples/locks#readme">https://github.com/spring-cloud-samples/locks#readme</a> 来进行了解 Spring cloud 全局锁的作用。</p>
<p>全局锁（Global locks）是对某部分进行加锁，当你只需要将某个部分只处于 <strong>只读状态</strong> 时，可以使用，之后这些部分进行更新、删除等将会造成阻塞。</p>
<h3 id="领导选举和集群状态（Leadership-election-and-cluster-state）"><a href="#领导选举和集群状态（Leadership-election-and-cluster-state）" class="headerlink" title="领导选举和集群状态（Leadership election and cluster state）"></a>领导选举和集群状态（Leadership election and cluster state）</h3><p>领导选举和集群状态（Leadership election and cluster state）由 <strong>Spring Cloud Cluster</strong> 所提供分布式系统集群功能，以及包含了领导选举、集群状态以及全局锁。</p>
<p>这些都被 Spring Integration 中的代码取代。</p>
<h3 id="分布式消息传递（Distributed-messaging）"><a href="#分布式消息传递（Distributed-messaging）" class="headerlink" title="分布式消息传递（Distributed messaging）"></a>分布式消息传递（Distributed messaging）</h3><p>通过消息总线（Bus）组件，数据流操作组件可以 Redis、RabbitMQ、Kafka等进行封装，<strong>来实现消息的接收和发送</strong>。</p>
<h2 id="主要项目"><a href="#主要项目" class="headerlink" title="主要项目"></a>主要项目</h2><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210525113017.png"></p>
<p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210608202600.png"><br>下述有些并不完全是 Spring cloud 自己的，而是通过根据 Spring boot 风格对这些组件进行封装，屏蔽了复杂的配置和原理，最终给开发人员提供了一个简单易懂和易部署以及平滑的的微服务框架。</p>
<h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><p>Spring cloud config 是 spring cloud 的配置管理工具，通过此项目可以将配置信息放到远程服务器中，从而集中管理集群配置。除此之外还可支持：本地存储、git、subversion 三种方式，<strong>这些资源还可直接映射到 Spring 环境</strong>。</p>
<h3 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h3><p>各种 Netifix OSS组件，由 Eureka，Hystrix ，Zuul，Archaius 等集成。</p>
<h3 id="Spring-Coud-Bus"><a href="#Spring-Coud-Bus" class="headerlink" title="Spring Coud Bus"></a>Spring Coud Bus</h3><p>将 <strong>服务实例与分布式消息传递</strong> 连接在一起的 <strong>事件总线</strong>，可以在集群中传播状态更改（如配置更改），还可与 Spring Cloud Config 联合实现热部署。</p>
<h3 id="Spring-Cloud-Cloudfoundry"><a href="#Spring-Cloud-Cloudfoundry" class="headerlink" title="Spring Cloud Cloudfoundry"></a>Spring Cloud Cloudfoundry</h3><p>Spring cloud 集成了 Foundry ，他是由 VMware 第一个业界推出的开源 Paas（Platform as a Service，平台即服务）的云平台。支持多种框架、语言、运行环境、平台及应用服务，基于这些可让开发人员快速在几秒中能进行部署和扩展，提供了服务发现，还可以轻松的实现 SSO、OAuth2保护资源。</p>
<h3 id="Spring-Cloud-Open-Service-Broker"><a href="#Spring-Cloud-Open-Service-Broker" class="headerlink" title="Spring Cloud Open Service Broker"></a>Spring Cloud Open Service Broker</h3><p>为实现构建 Open Service Broker API（开放服务器代理接口），可以为开发人员能够为开发人员对平台（如Spring Foundry、Kubernetes）中运行的应用提供服务。</p>
<h3 id="Spring-Cloud-Cluster"><a href="#Spring-Cloud-Cluster" class="headerlink" title="Spring Cloud Cluster"></a>Spring Cloud Cluster</h3><p>提供了分布式系统集群所需要的基础功能支持，如选举、集群状态一致性、全局锁、Tokens 等常见状态模式的抽象和实现。</p>
<h3 id="Spring-Cloud-Consul"><a href="#Spring-Cloud-Consul" class="headerlink" title="Spring Cloud Consul"></a>Spring Cloud Consul</h3><blockquote>
<p>Consul 是由 HashiCorp 公司所使用 Go 所开发的服务治理项目</p>
</blockquote>
<p>Spring cloud Consul 主要封装了 Consul 来实现服务治理、健康检查、key-Values 存储、数据中心集群的呢个。</p>
<h3 id="Spring-Cloud-Security"><a href="#Spring-Cloud-Security" class="headerlink" title="Spring Cloud Security"></a>Spring Cloud Security</h3><p>提供对 Zuul 代理中复杂均衡的 OAuth2、REST 客户端和身份验证头中继的支持。</p>
<h3 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h3><p>Spring cloud sleuth 为 spring cloud 服务之间的调用提供了链路追踪，封装了 Dapper、Log-based 追踪（ELK）、Zipkin 和 HTrace 操作。</p>
<h3 id="Spring-Cloud-Data-Flow"><a href="#Spring-Cloud-Data-Flow" class="headerlink" title="Spring Cloud Data Flow"></a>Spring Cloud Data Flow</h3><p>针对现代运行时可组合的微服务应用程序的原生编排服务，易用于 DSL、拖放 GUI 和 restAPI 一起简化了基于微服务的数据管道整体编排。即提供了统一变成模型和托管服务，用于开发和执行 ETL、一种用于处理大规模数据的模式。</p>
<h3 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h3><p>一个轻量级事件驱动的微服务框架，用于快速构建可以链接到外部系统的应用程序。基于 Spring boot 创建，通过事件触发任务，封装了 Redis、Rabbit、Kafka等发送和接收消息，用来创建工业级的 Spring 应用。</p>
<h3 id="Spring-Cloud-Stream-Application"><a href="#Spring-Cloud-Stream-Application" class="headerlink" title="Spring Cloud Stream Application"></a>Spring Cloud Stream Application</h3><p>Spring cloud Stream 应用程序是现成的 Spring 引导应用程序，使用 spring cloud stream 中的 binder 抽象提供与外部中间件系统（ApacheKafka、RabbitMQ……）的集成。</p>
<h3 id="Spring-Cloud-Task"><a href="#Spring-Cloud-Task" class="headerlink" title="Spring Cloud Task"></a>Spring Cloud Task</h3><p>一个短暂的微服务框架，主要用于进行微服务的任务管理和调度等。</p>
<h3 id="Spring-Cloud-Task-App-Starters"><a href="#Spring-Cloud-Task-App-Starters" class="headerlink" title="Spring Cloud Task App Starters"></a>Spring Cloud Task App Starters</h3><p>Spring cloud 任务应用启动程序是 spring boot 应用程序，可以是任何进程，包括不会永远运行的 Spring 批处理作业，他们可以在有限的数据处理周期后 <strong>结束或停止</strong></p>
<h3 id="Spring-Cloud-Zookeeper"><a href="#Spring-Cloud-Zookeeper" class="headerlink" title="Spring Cloud  Zookeeper"></a>Spring Cloud  Zookeeper</h3><p>Spring cloud 集成了 Zookeeper，他是 Hadoop 和 Hbase 的重要组件，<strong>提供了配置维护、域名服务、分布式同步、组服务、服务治理等功能</strong>。</p>
<h3 id="Spring-Cloud-Connectors"><a href="#Spring-Cloud-Connectors" class="headerlink" title="Spring Cloud Connectors"></a>Spring Cloud Connectors</h3><p>使各种平台上的PaaS（Platform as a Service，平台即服务）应用程序能够轻松地连接到后端服务。也就是说可以通过他来链接到服务和从云平台获取操作的过程，拥有很强的扩展性，可用于构建云平台。</p>
<h3 id="Spring-Cloud-Starters"><a href="#Spring-Cloud-Starters" class="headerlink" title="Spring Cloud Starters"></a>Spring Cloud Starters</h3><p>一个 Spring boot 风格的启动应用项目，可以简化 Spring Cloud 使用者的依赖管理关系（在 Angel.SR2之后停止为一个项目，并与其他项目合并），为 Spring cloud 提供了一个 <strong>开箱即用</strong> 的依赖管理。</p>
<h3 id="Spring-Cloud-CLI"><a href="#Spring-Cloud-CLI" class="headerlink" title="Spring Cloud CLI"></a>Spring Cloud CLI</h3><p>Spring boot CLI 插件，用于在 Groovy 中快速创建 SPring Clound 组件应用程序，即通过 Spring cloud CLI 可以 <strong>快速构建云组件</strong>。</p>
<h3 id="Spring-Clound-Contract"><a href="#Spring-Clound-Contract" class="headerlink" title="Spring Clound Contract"></a>Spring Clound Contract</h3><p>Spring cloud 通过 CDC (Customer Driven Contracts，客户驱动合同)开发，基于JVM（Java 虚拟机，Java virtual machine）的应用提供了支持，为TDD（测试驱动开发）提供一种新的基于接口的测试方法。</p>
<h3 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h3><p>Spring cloud Gateway 是一个基于Project Reactor 项目，为 Spring cloud 提供了一种简单和有效的方式来对 <strong>为服务的 API 进行路由</strong>。</p>
<h3 id="Spring-Cloud-OpenFeign"><a href="#Spring-Cloud-OpenFeign" class="headerlink" title="Spring Cloud OpenFeign"></a>Spring Cloud OpenFeign</h3><p>Spring cloud OpenFeign 由于封装声明试 Web Service 客户端的 Feign，可以让编写 Web Service client 变得容易。支持 Feign 注解和 JAX-RS 注解，支持热插拔的编码器和解码器，并支持 Feign 在 Spring MVC 中使用，由于整合了 Ribbon 和 Eureka 可以在使用 Feighn 时提供负载均衡。</p>
<h3 id="Spring-Cloud-Pipelines"><a href="#Spring-Cloud-Pipelines" class="headerlink" title="Spring Cloud Pipelines"></a>Spring Cloud Pipelines</h3><p>Spring Cloud Pipelines 提供了一个可靠的部署管道，其中包含了一些步骤，来确保应用程序可以零停机的方式部署，并且在出现问题时可以轻松的回滚。</p>
<h3 id="Spring-Cloud-Function"><a href="#Spring-Cloud-Function" class="headerlink" title="Spring Cloud Function"></a>Spring Cloud Function</h3><p>Spring Cloud Function 提供了一通用的模型，在类似与 AWS Lambda 这种 FaaS（Function as a Service，函数驱动服务）平台上部署函数软件。</p>
<h2 id="Netfix-项目"><a href="#Netfix-项目" class="headerlink" title="Netfix 项目"></a>Netfix 项目</h2><p>除了 Spring cloud 项目本身，其他厂商也对其微服务等开源产品作出巨大的公司，如 Netfix 和 Alibaba 等公司，但 Netfix 要早于 Alibaba 对微服务及其相关产品或项目的贡献。</p>
<p>Spring Cloud 集成了 Netfix 公司所开源的各种项目和组建其中主要以 Eureka、Hystrix、Zuul、Archaius 作为为代表项目。</p>
<h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><p>Eureka 是一个基于 REST 服务的服务治理组件，主要包含了服务注册和服务发现两个最为核心的功能。</p>
<h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><p>Spring cloud 可以整合 Hystrix 来对微服务进行容错管理，即使将服务做成集群也不 100% 保证安全可用。为了防止服务与服务之间的依赖性，<strong>单个服务出现故障</strong> 从而导致整个为服务系统崩溃，则需要进行容错管理。</p>
<h3 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h3><p>Zuul 为 Spring cloud 提供了路由和过滤的功能，他是一种服务的统一入口，除此还提供了动态路由、监控、授权、安全、调度等功能。</p>
<h3 id="Archaius"><a href="#Archaius" class="headerlink" title="Archaius"></a>Archaius</h3><p>Spring cloud 整合了 Archaius 来进行 管理和配置 API，Archaius 提供了动态类型化属性、线程安全配置操作，轮询框架，回调机制等功能。</p>
<blockquote>
<p>Archaius 可以实现出动态获取配置，如默认每隔60s从配置源读取一次内容，<strong>这样在修改配置文件后不需要重新启动服务，即可使得修改的内容生效</strong></p>
</blockquote>
<h2 id="Alibaba-项目"><a href="#Alibaba-项目" class="headerlink" title="Alibaba 项目"></a>Alibaba 项目</h2><p>在 2019年10月所发布的《颠覆性公司和商业模式》报告中，Alibaba 以 15% 成功位居第三位，百度、腾讯等均位列第十和第十一位。</p>
<h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><p>Sentinel 是一个流控制组件，可以将流量作为切入点，从流量控制、熔断降级、系统负载保护等多个阶段保证服务的稳定性。</p>
<h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p>Nacos 是一个服务治理的项目，与 Eureka、Consul 一样，提供了动态服务发现、配置管理和服务管理平台。</p>
<h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>RocketMQ 是基于分布式高可用集群提供的低延迟、高可靠的消息发布&#x2F;订阅服务，类似与 RabbitMQ 的一种消息中间件。</p>
<h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><p>Dubbo 是一个高性能、轻量级的开源 Java 服务框架，提供了面向接口代理的高性能RPC（Romote Procedure Call，远程过程调用），智能容错、负载均衡、服务自动注册和发现、运行期流量调整、可视化服务治理与运维等。</p>
<h3 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h3><p>Seata是一款分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</p>
<h3 id="Alibaba-Cloud-ACM"><a href="#Alibaba-Cloud-ACM" class="headerlink" title="Alibaba Cloud ACM"></a>Alibaba Cloud ACM</h3><p>Alibaba Cloud ACM 是一个应用配置中心，用于分布式架构环境中对 <strong>应用配置进行集中的管理和推送。</strong></p>
<h3 id="Alibaba-Cloud-SchedulerX"><a href="#Alibaba-Cloud-SchedulerX" class="headerlink" title="Alibaba Cloud SchedulerX"></a>Alibaba Cloud SchedulerX</h3><blockquote>
<p>Cron 是一个基于时间的任务管理系统，可通过 cron 在固定时间、日期、间隔的情况下运行任务。</p>
<p>除此之外他的表达式特别的不具有可读性：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件格式說明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">┌──分鐘（0 - 59）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">│ ┌──小時（0 - 23）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">│ │ ┌──日（1 - 31）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">│ │ │ ┌─月（1 - 12）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">│ │ │ │ ┌─星期（0 - 6，表示从周日到周六）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">│ │ │ │ │</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">*  *  *  *  * 被執行的命令</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如 <code>1-6 * * * * echo hello world</code> 及每小时的 1～6分钟内，都会都会打印 Hello,world符号。</p>
<p>更多可参考 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Cron">https://zh.wikipedia.org/wiki/Cron</a></p>
</blockquote>
<p>基于 Cron 表达式的任务调度服务，可以提供秒级、精准、高可靠、高可用的定时任务调度功能，可以支持  cron、fixed_rate、second_delay 定时调度，能精确到秒级别。</p>
<h2 id="架构对比"><a href="#架构对比" class="headerlink" title="架构对比"></a>架构对比</h2><h3 id="Spring-cloud"><a href="#Spring-cloud" class="headerlink" title="Spring cloud"></a>Spring cloud</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210525113017.png"></p>
<h3 id="Dubbo-1"><a href="#Dubbo-1" class="headerlink" title="Dubbo"></a>Dubbo</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210525161842.png"></p>
<p>Dubbo 比 Spring cloud <strong>少了很多配套项目（因为不是 spring 全家桶内的）</strong>，所以 Dubbo 专注与 RPC 领域，未来将会成为微服务生态体系中一个重要的 <strong>组件</strong>，而不是 <strong>微服务的全面解决方案</strong>。</p>
<h3 id="lstio"><a href="#lstio" class="headerlink" title="lstio"></a>lstio</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210525161902.png"><br>lstio 主要使用网格服务 Service Mesh 架构来实现，因此在 lstio 中，服务之间的通信主要通过 Envoy 代理来使用 <strong>HTTP&#x2F;1.1、HTTP2、gRPC、TCP</strong> 来进行，Pilot、Mixer、Citadel 来组成的控制平台。</p>
<h4 id="pilot"><a href="#pilot" class="headerlink" title="pilot"></a>pilot</h4><p>为 Envoy 提供服务发现、流量管理、智能路由、错误处理（含超时、重试、融断）的功能，因此用户可以通过 Pilot 的 API 管理网络相关的资源对象。Pilot 会根据用户的配置和服务的信息将网络流量管理信息分发到各个 Envoy 中。</p>
<h4 id="Mixer"><a href="#Mixer" class="headerlink" title="Mixer"></a>Mixer</h4><p>主要为整个 集群执行访问控制、跨服务网格使用策略（Policy）、管理（Rate Limit、Quota）bing souji cong  Envoy 代理和其他服务自动探测到的数据，Mixer 包含了一个非常灵活的模型插件。<strong>可以与各种主机环境和后端基础架构进行交互，他是一个独立于平台的组件</strong>。</p>
<h4 id="Citadel"><a href="#Citadel" class="headerlink" title="Citadel"></a>Citadel</h4><p>提供了服务之间的认证和证书管理，能够自动升级到 TLS 协议</p>
<h4 id="Sidecar"><a href="#Sidecar" class="headerlink" title="Sidecar"></a>Sidecar</h4><p>在原有的客户端和服务器端之间添加了一个代理程序。</p>
<h4 id="Envoy"><a href="#Envoy" class="headerlink" title="Envoy"></a>Envoy</h4><p>提供了服务发现，负载均衡和路由表动态更新的 API这些分别解决了 lstio 和 Envoy 的问题，Proxy 作为 SideCar 会和控制中心动心，来获取需要的服务之间的信息，以及回报服务调用的  Metrics（指标） 数据</p>
<h1 id="Sprng-cloud-优缺点"><a href="#Sprng-cloud-优缺点" class="headerlink" title="Sprng cloud 优缺点"></a>Sprng cloud 优缺点</h1><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210528095543.png"></p>
<h2 id="微服务优点"><a href="#微服务优点" class="headerlink" title="微服务优点"></a>微服务优点</h2><h3 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h3><p>以上图作为参考，我们可以首先得知微服务是以 <strong>分布式</strong> 作为必要技术。有多个微小服务所组成的一个应用，由于他将一个功能划分为一个很小的服务，可以将一个微服务交给不同的开发人员或团队进行开发。</p>
<p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210530202957.png"></p>
<p>也就是说不同的开发团队可以同时完成多个属于自己任务范围内的 “微服务”，进行项目开发，因此可以 <strong>易于开发和维护</strong>，而不是向单一应用一样一个项目几百个文件夹，都涉及不同的功能和服务。</p>
<h3 id="代码量"><a href="#代码量" class="headerlink" title="代码量"></a>代码量</h3><p>与单个服务相比，微服务由于功能只针对一个功能所进行提供服务。因此代码量不会像正常的单一应用较多，所以项目的启动速度是比单一应用较快的。（但这也不算是优点，因为启动时还很麻烦，一个一个启动多个微服务）</p>
<h3 id="易于更新迭代"><a href="#易于更新迭代" class="headerlink" title="易于更新迭代"></a>易于更新迭代</h3><p>如果只是小型的项目迭代的话，那么微服务由于是多个服务应用组成的一个庞大服务，所以我们可以根据目标 <strong>功能对应的微服务</strong> 模块直接进行修改后上传。不需要向单体应用一样直接暂停项目并进行修改后发布。</p>
<h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>由于微服务是以业务单一性为原则的开发模式，因此他的开发也不会是统一一种语言，他可以是多个，且不冲突。</p>
<h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>解耦是在设计模式中较为常见的名词之一，各类书籍中经常出现但就是不给你解释。解耦通俗来说就是两个东西 <strong>原来互相影响</strong>，现在然他们 <strong>分别发展</strong>，但不是完全的分别发展，而是在原有的基础上降低两者互相的依赖关系。其核心思想是最小职责，每个地方做一件事情。</p>
<p>通常情况下 <strong>松耦合</strong> 也可以被称之为 <strong>解藕</strong>，瞬间让此变得高端大气上档次。因此除了松耦合外，</p>
<blockquote>
<p>他还有一个反意为 <strong>紧耦合</strong>，指的是两个模块之间相互影响且关系紧密，存在着互相关系调用。</p>
</blockquote>
<h3 id="具有弹性"><a href="#具有弹性" class="headerlink" title="具有弹性"></a>具有弹性</h3><p>由于微服务非常可以简单的实现 <strong>服务集群</strong>，通过 <strong>服务治理组件</strong>来实现服务的治理，通常都是两三个集群一起工作。一台蹦了还有另一台，另一台蹦了又换下一台的局面，可以保证服务的正常运行。除此之外还具有水平扩展独立以及扩展性高等优点。</p>
<h2 id="微服务缺点"><a href="#微服务缺点" class="headerlink" title="微服务缺点"></a>微服务缺点</h2><h3 id="分布式复杂性"><a href="#分布式复杂性" class="headerlink" title="分布式复杂性"></a>分布式复杂性</h3><p>对微服务来说分布式架构是一个非常必要的技术，但因为分布式依赖服务较多，一旦其中某个 <strong>依赖服务</strong> 以及系统的容错能力都会带来挑战。</p>
<h3 id="分布式事务问题"><a href="#分布式事务问题" class="headerlink" title="分布式事务问题"></a>分布式事务问题</h3><p>所谓分布式事务问题可以分为 <strong>可靠事件模式（Reliable Event Mode）、补偿模式（Confirm Cancel）、TCC（Try Confirm Cancel）</strong> 三种，用于解决分布式的 <strong>事务一致性问题</strong>。</p>
<p>首先我们需要知道为什么要有服务一致性，假设你在 Wechat 中将 100RMB 转账给 B，那么 B 的 Wechat 钱包就会多 100RMB。但如果这个过程中 Wechat 服务崩了，那你将会少 100RMB，而B的钱包数额不变。</p>
<h4 id="可靠事件模式（Reliable-Event-Mode）"><a href="#可靠事件模式（Reliable-Event-Mode）" class="headerlink" title="可靠事件模式（Reliable Event Mode）"></a>可靠事件模式（Reliable Event Mode）</h4><p>他也被称之为 可靠事件记录协议（RELP，Reliable Event Logging Protocol），是一种用于计算机网络中记录 <strong>计算机数据的网络协议</strong>。</p>
<p>他可以提供消息的可靠传递，常用与不能让数据丢失的环境，如转账。在这里我们需要认清 <strong>可靠事件记录协议和可靠事件模式</strong>，在通常的情况下，<strong>可靠事件模式是可靠事件记录协议的实现</strong></p>
<p>一般情况下事件操作可以被分为三种可能，分别为：</p>
<ol>
<li>操作成功，投递事件</li>
<li>操作失败，投递事件失败</li>
<li>操作成功，投递失败，抛出异常 | 回滚</li>
</ol>
<h5 id="本地事件表"><a href="#本地事件表" class="headerlink" title="本地事件表"></a>本地事件表</h5><p>因此可靠事件模式主要通过 <strong>本地事件表和外部事件表</strong> 两者来就进行可靠事件投递。</p>
<p>本地事件表通过将事件和业务数据保存在同一个数据库中，来以一个额外的 <strong>事件恢复服务</strong> 来恢复事件。</p>
<blockquote>
<p>原子性指一个操作不可中断，要么全部成功，要么全部失败的原则即称之为 原子性。</p>
</blockquote>
<p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210531112717.png"></p>
<p>这些都将会由本地事务来保证更新业务的发布事件中的不可中断，要么全部成功，要么全部失败，即原子性。</p>
<h5 id="外部事件表"><a href="#外部事件表" class="headerlink" title="外部事件表"></a>外部事件表</h5><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210531112826.png"><br>外部事件表是针对本地事件表出现的问题，单个提出外部事件表的方法。将 <strong>事件持久话到外部事件系统服务中</strong>，事件系统需要提供一个实时的事件服务以用于接收 <strong>为服务发布的事件</strong> 。与此同时还需要提供一个恢复服务来确定和恢复事件。</p>
<p>事物提交前，业务系统会通过实时事件服务向系统请求发送事件，事件系统 <strong>只记录事件但并不发送</strong>。</p>
<p>之后业务服务提交后，通过实时事件服务向 &#x3D;&gt;<strong>事件系统</strong> 确认发布，事件得到确认后 <strong>事件系统</strong> 进行发布到消息代理。</p>
<p>当业务系统回滚时，通过实时事件向时间系统<strong>去取消</strong>事件。假设事件系统的事件恢复服务定期找到未确定发送事件向业务服务查询状态时，根据业务服务返回的状态来决定事件是否需要发布。</p>
<h4 id="补偿模式（Confirm-Cancel）"><a href="#补偿模式（Confirm-Cancel）" class="headerlink" title="补偿模式（Confirm Cancel）"></a>补偿模式（Confirm Cancel）</h4><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210601041306.png"><br>补偿模式主要有 <strong>业务异常和技术异常</strong> 两个概念，是自身业务所造成的。而技术异常则是非业务逻辑产生的一系列问题，如网络异常等。</p>
<p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210601041315.png"><br>因此补偿模式需要使用一个 <strong>额外的协调服务来协调微服务保证一致性</strong>，这时候协调服务通过按照顺序调用服务，如果某个服务出现异常则直接取消之前所有已经成功调用的服务(所以他也具有原子性)。</p>
<p>也就是说当数据文件为空时提交，那么之前所填写的端口信息以及提交数据都将会被取消，而这所取消的就是一个 <strong>补偿</strong></p>
<h4 id="TCC-模式（Try-Confirm-Cancel）"><a href="#TCC-模式（Try-Confirm-Cancel）" class="headerlink" title="TCC 模式（Try Confirm Cancel）"></a>TCC 模式（Try Confirm Cancel）</h4><p>TCC 模式由 Try、Confirm、Cancel 三个接口，一个完整的 TCC应用由 <strong>主业务、若干个业务服务</strong> 组成和发起，并最后通过主业务完成整个活动。</p>
<p>TCC 三个接口分别意思为：</p>
<ol>
<li>try：完成所有业务检查，预留必须存在的业务资源</li>
<li>Confirm：执行业务，不做任何业务的检查和分析，只是用 try 阶段所预留的业务资源，Confirm 操作满足幂等性。</li>
</ol>
<blockquote>
<p>幂等性，就是说一个系统，在同样情况下一次请求和 <strong>重复</strong> 多次请求对资源造成一致的就是幂等性。</p>
</blockquote>
<ol start="3">
<li>Cancel 释放 try 阶段预留资源（满足幂等性？）</li>
</ol>
<p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210601041321.png"></p>
<p>主业务服务调用所有的业务的 try 操作，之后在活动管理器中登记所有业务服务，当所有业务服务的 try 操作都调用成够后或从某个业务服务的 try 操作失败进入 confirm 阶段。</p>
<p>活动管理器根据 try 执行结果来执行 confirm or cencel 操作，如果 try 操作所有都成功则从活动管理器中调用所有 confirm 操作，否则将调用 cancel 来释放 try 预留资源。</p>
<h3 id="分布式同步调用"><a href="#分布式同步调用" class="headerlink" title="分布式同步调用"></a>分布式同步调用</h3><p>分布式的同步调用及主要是在不确定环境中无法保证所依赖服务，但可以保证自己可以正常提供服务的情况。</p>
<h4 id="SEDA"><a href="#SEDA" class="headerlink" title="SEDA"></a>SEDA</h4><p>阶段式服务器模型（SEDA，Staged event-driven architencure）他是一个软件架构模型，可以将复杂的事件驱动的应用分解为一系列通过队列链接的阶段（Stage）。</p>
<p>在上述中 “分布式的同步调用及主要是在不确定环境中无法保证所依赖服务，但可以保证自己可以正常提供服务的情况。”就可以通过使用 SEDA 进行解决。</p>
<p>拥用一句话概括就是 <strong>将请求出来过程划分为多个阶段，不同资源消耗阶段，并使用不同数量的线程进行处理</strong>。</p>
<h3 id="接口调整"><a href="#接口调整" class="headerlink" title="接口调整"></a>接口调整</h3><p>由于微服务数量可能会有很多，因此如果需要调整接口时则需要话费很大的时间。除了调整外还需要写其接口文档，来进行管理。</p>
<p>而接口文档可以从中心点引入很多下游问题，如接口文档的管理和更新等。</p>
<h1 id="Spring-cloud-微服务设计原则"><a href="#Spring-cloud-微服务设计原则" class="headerlink" title="Spring cloud 微服务设计原则"></a>Spring cloud 微服务设计原则</h1><h2 id="AKF-可扩展性原则"><a href="#AKF-可扩展性原则" class="headerlink" title="AKF 可扩展性原则"></a>AKF 可扩展性原则</h2><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210601161731.png"><br>Spring cloud 的单一设计原则可以让微服务更加优雅。在这个原则之下所开发的微服务项目通常 <strong>只关注单一的功能，有限的业务逻辑</strong> 最终完成一个有限的业务逻辑。</p>
<p>就比如 AKF 拆分原则即 <strong>扩展立方体（Scalability Cube）或 AKF Scale Cube</strong>，需要注意的是 AKF 并不是什么单词缩写，而是一个公司的名称。</p>
<p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210601161741.png"><br>我们可以直接概括下这三个轴的主要左右，其中Y轴是功能划分以及基于不同业务之间的划分。而 X轴则是水平扩展，北其名曰水平复制，来砸钱解决问题（加服务器）。最后就是Z轴，Z轴主要左右就是数据区分，来关注服务和数据的优先级进行划分。</p>
<h3 id="Y-Axis"><a href="#Y-Axis" class="headerlink" title="Y Axis"></a>Y Axis</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210602025515.png"><br>Y 轴会会根据基于不同业务之间的整体应用拆分为多个服务，每个服务主要会实现一个单个功能。之后以 Eureka 服务治理为例，通过服务中心来进行治理，最终架构如上所示。</p>
<h3 id="X-Axis"><a href="#X-Axis" class="headerlink" title="X Axis"></a>X Axis</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210602025526.png"><br>X 轴主要是水平扩展，通过复制服务与数据来解决可用性及微服务集群的问题，也就是说将微服务运行多个实例（集群），来通过集群负载均衡的模式来提升服务整体的可用性。</p>
<h3 id="Z-Axis"><a href="#Z-Axis" class="headerlink" title="Z Axis"></a>Z Axis</h3><p>Z轴主要就是区分数据，通常Z轴扩展有两种方案分别为 <strong>单元化架构以及数据分区</strong> 两种，以大数据时代的今天可能两者都会被使用，</p>
<p><strong>单元化架构</strong><br><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210602025537.png"><br>单元化架构的选择主要根据服务的类型以及对象单元是否符合来进行区分，如客户端对服务端节点的选择都将是单元自成一体。</p>
<p><strong>数据分区</strong><br><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210602025543.png"><br>数据区分也叫分区（Shard），他其实就是区分数据的，比如说我们可以根据年龄、注册时间来区分数据。通常会包含一下几个数据划分的方式，这也是最为常见的：</p>
<ol>
<li>数据类型</li>
<li>数据范围</li>
<li>数据热度</li>
<li>数据分区</li>
</ol>
<p>这四种最为常见的我们可以在很多大型应用中看到，如 bliblibli 弹幕网，因为咱们也没有看过他们的源代码，但是我们可以随便以肉眼可见的观察下，就会发现他们做了一个非常细致的数据区分。</p>
<h2 id="服务自治"><a href="#服务自治" class="headerlink" title="服务自治"></a>服务自治</h2><p>说到 Spring cloud，我们从第三节到现在就一直说他多么多么服务自治，看上去非常高端且难懂。实际上服务自治简单来讲就是 <strong>每个微服务都具有独立性质，及运行、开发、测试、构建、部署</strong> 且包含数据库都可独立运行的服务。而过多或依赖其他微服务，并与其高度解耦，除此之外我们将此称之为 服务自治。</p>
<p>服务自治也是名副其实的微服务设计原则，因为他可以打来很多的好处，如团队协作、技术栈、后续迭代、持续集成等多种优势。</p>
<h2 id="轻量级通信"><a href="#轻量级通信" class="headerlink" title="轻量级通信"></a>轻量级通信</h2><p>轻量级接口通信主要对其要求就是体量较轻，可以跨语言和跨平台之间的通信，以及可以不受技术限制，实现不同通信协议之间的通信，如：REST、RPC、AMQP、STOMP、MQTT等。</p>
<h2 id="接口明确原则"><a href="#接口明确原则" class="headerlink" title="接口明确原则"></a>接口明确原则</h2><p>而接口明确原则，则是为了确保之后微服务之间不断的完善，导致因为某个接口的变化而其他服务集群需要进行调整，为了避免此类令人烦恼的事情再次发生，则需要让这些接口在设计开发的时候更加的具有通用性。</p>
<h2 id="容错性设计原则"><a href="#容错性设计原则" class="headerlink" title="容错性设计原则"></a>容错性设计原则</h2><p>容错性设计原则也被称之为弹性设计，即依赖服务宕机、网络或硬件出现问题时可以暂停使用服务，切换下一个资源，在后续我们将会以集群的方式解决这个问题。除此之外也有很多成熟可靠的方案进行选择，如 Hystrix 延迟和容错库。</p>
<h2 id="自动化原则"><a href="#自动化原则" class="headerlink" title="自动化原则"></a>自动化原则</h2><h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><p>自动化原则主要会分为自动化测试、自动化监控和自动化部署等三种非常主要的自动化方案。其中自动化测试可以减轻测试负担，可以保障微服务的模块在高流量的情况下可访问。</p>
<h3 id="自动化监控"><a href="#自动化监控" class="headerlink" title="自动化监控"></a>自动化监控</h3><p>而自动化监控则是监控微服务状态，发现问题以及错误计数等来便于解决和发现问题，也可以根据监控状态来调整负载，来保证服务的稳定性和高可用等。在 Spring cloud 项目中，提供了一个为服务可用性监控 Spring Boot Admin 组件。</p>
<h3 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h3><p>自动化部署指的是将代码自动部署到生产环境中，来减少项目发布的时间，目前可以通过 Jenkins + Fastlane 来搭配使用。</p>
<h1 id="Spring-cloud-业务拆分与管理模式"><a href="#Spring-cloud-业务拆分与管理模式" class="headerlink" title="Spring cloud 业务拆分与管理模式"></a>Spring cloud 业务拆分与管理模式</h1><h2 id="Domain-Driver-Design（DDD）"><a href="#Domain-Driver-Design（DDD）" class="headerlink" title="Domain Driver Design（DDD）"></a>Domain Driver Design（DDD）</h2><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210603031247.png"><br>在微服务设计中，我们通常会存在一种不知道如何进行划分的问题，到底是根据功能、组织结构进行划分还是其他方式。</p>
<p>而为了解决这种问题，领域驱动设计（Domain Driver Design）提供了一种划分方法论，说白了就是可以解决微服务划分时遇到的问题。</p>
<p>首先，DDD 主要结构为四层，分别为 <strong>基础设施层 (Infrastructure)、领域层 (Domain)、应用层 (Application)、用户界面层 (Interfaces)（也被称为表示层、展现层、接口层）</strong></p>
<h3 id="领域"><a href="#领域" class="headerlink" title="领域"></a>领域</h3><p>首先，我们需要通过 DDD 来指导我们的划分方法，而不是让他主导我们，从而让我们更加困惑。因此我们需要知道一件事情，就是 <strong>分清问题和方案</strong>，问题是需要解决的，而方案是用来解决问题的。</p>
<p><strong>当谈论领域的时候（含子域、通用子域）实际上都是在讨论问题域</strong>，而问题域就是 <strong>我们需要解决什么问题</strong></p>
<p>而到 <strong>限界上下文、聚合、实体、仓库</strong> 这些实际上是在 <strong>谈论解决方案</strong> 来解决领域时提出的问题。</p>
<p>在搜索领域中，我们可以从其主页面中来看出遇到的一些非常典型的问题：</p>
<ol>
<li>如何保持知名度</li>
<li>如何让搜素变得更精准</li>
<li>如何找到一个合适的度进行营销</li>
</ol>
<p>而这些问题的解决问题的方案可以是：</p>
<ol>
<li>与浏览器之间进行绑定</li>
<li>加大数据爬取和关键词的定位</li>
<li>与搜索结果中布局一致</li>
</ol>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>在设计中，主要解决的就是让领域专家和技术专家深入合作，并建立一个软件问题提模型，而这个模型主要可以解决：</p>
<ol>
<li>可以表达领域概念和业务流程</li>
<li>每个领域都有自己的解决方案</li>
</ol>
<p>这就是设计在 DDD 主要的作用，DDD 是一种基于领域为中心来驱动的软件的开发思想，可以通过此来帮助我们解决复杂的业务问题，因此需要对每个 <strong>领域提出问题来对应一个领域模型，来解决问题</strong>。</p>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>在 DDD 中，主要将模型划分为四层，分别为基础层（Infrastructure）、领域层（Domain）、应用层（Application）、用户界面层（Interfaces），这些被简称为 IDAI。</p>
<p>通俗来讲模型就是一个解决方案空间，是一个为了准确定义需要问题而构造的一个抽象模型。而模型主要可以解决类似与业务领域问题，以及分析满足系统的功能性要求即 IDAI。</p>
<h3 id="专家"><a href="#专家" class="headerlink" title="专家"></a>专家</h3><p>通过领域提出的问题我们可以得知，这些问题的提出基本上不是开发人员非常擅长的，所以此时需要 <strong>领域专家</strong> 来提出问题，由 <strong>技术专家</strong> 解决问题，这也是 DDD 成功实施的主要条件。</p>
<h2 id="事务管理模式"><a href="#事务管理模式" class="headerlink" title="事务管理模式"></a>事务管理模式</h2><p>事物管理模式（ACID，Atomicity Consistency Isolation Durability）要比 DDD 更好理解，他在上一章就以一小部分的形式出现了，当时我们所介绍的是原子性（Atomicity）。</p>
<p>一个逻辑工作单元需要成为事物，需要满足 ACID属性，分别为：</p>
<ol>
<li>A：原子性（Atomicity），事物操作中，要么全做，要么都不做</li>
<li>C：一致性（Consistency），事务执行完后，从同样状态，转向另一个同样的状态（可以理解为要么是全部执行中，要么是全部暂停中）</li>
<li>I ：隔离性（Isolation），事务执行时不被打扰</li>
<li>D：持久性（Durability），事务提交后，对数据的改变就是永久性的。</li>
</ol>
<h3 id="2-x2F-3PC"><a href="#2-x2F-3PC" class="headerlink" title="2&#x2F;3PC"></a>2&#x2F;3PC</h3><p>2&#x2F;3PC 算法模式（Two &#x2F; Three Phase Commit，二&#x2F;三阶段提交）主要是为了让分布式系统在事务处理时 <strong>可以实现 ACID属性</strong> 所设计的算法。</p>
<h4 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h4><p>首先我们可以将他看成两个阶段，一个是 <strong>欲提交</strong>，而另一个则是 <strong>提交</strong> 阶段，其中：</p>
<h5 id="欲提交阶段"><a href="#欲提交阶段" class="headerlink" title="欲提交阶段"></a>欲提交阶段</h5><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210603031254.png"><br>欲提交阶段从名字就可以看出他并不是真正的提交阶段，而是处于向资源管理器询问是否可以提交，这其中主要分为三个阶段：</p>
<ol>
<li>向所有资源管理器发送询问</li>
<li>资源管理器执行事物操作，如资源上锁等</li>
<li>返回信息给事物管理器（成功情况下）</li>
</ol>
<h5 id="执行事务提交阶段"><a href="#执行事务提交阶段" class="headerlink" title="执行事务提交阶段"></a>执行事务提交阶段</h5><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210603031315.png"><br>执行事务提交阶段可以理解为欲提交阶段后的一个过程，他的主要有四个流程，分别为：</p>
<ol>
<li>请求提交：事务管理器向资源管理器发出提交请求</li>
<li>事务提交：资源管理器收到请求后，开始事务提交操作，完成后释放事务资源</li>
<li>反馈结果：完成事务提交之后，向事务管理器发送 <strong>已提交（ACK）</strong> 消息</li>
<li>完成事务：事务管理器收到了所有资源管理器反馈的 ACK 后即完成提交。</li>
</ol>
<p>假如其中某个资源管理器返回了未提交，或者说等待超时，那么将会中断事务，其流程如下：</p>
<ol>
<li>发送事务请求：事务管理器向资源管理器发送回滚请求</li>
<li>事务回滚：资源管理器通过撤销信息来执行事务回滚，释放事务资源</li>
<li>反馈事务回滚结果：完成事务回滚后发送 ACK （协调者发布）消息</li>
<li>中断事务：当事务管理器收到了来自所有参与者反馈的 ACK 消息后中断服务。</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><h6 id="堵塞"><a href="#堵塞" class="headerlink" title="堵塞"></a>堵塞</h6><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210603031323.png"><br>尽管 2PC 看似非常的优秀，但是如果认真品一下就会发现，这么多资源管理器，如果只有中某个资源管理器在执行事物提交阶段的时候，返回了 <strong>未提交</strong>，之后的所有提交是不是都需要进行等待而无法继续完成操作？</p>
<h6 id="单点"><a href="#单点" class="headerlink" title="单点"></a>单点</h6><p>单点即一旦事务管理器出现了问题，那么整个 2PC 的提交将无法运转。或者说一旦在提交的时候出现了问题，那么所有的资源管理器都会处于锁定状态，从而无法继续提供服务。</p>
<h4 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h4><p>3PC 和 2PC 不同之处在于他有三个阶段，分别为 <strong>欲提交（PreCommit）、可以提交（CanCommit）、提交（doCommit）</strong>。在3PC 中三个阶段都有一个核心的理念，即 <strong>询问时不会锁定资源管理器，除非所有人 Ack 了才开始锁</strong>，因此他解决了 2PC 的堵塞问题。</p>
<p>而单点问题 3PC 则通过假设资源管理器无法即时接收到来自事务管理器的信息，他们会默认执行 doCommit ，而不会一直卡在那里不动，最终导致无法提供服务。</p>
<h3 id="TTY-Try-Confirm-Cancel"><a href="#TTY-Try-Confirm-Cancel" class="headerlink" title="TTY Try-Confirm-Cancel"></a>TTY Try-Confirm-Cancel</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210604031506.png"><br>TTY 主要有三个接口，分别为 尝试（Try）、确认（Confirm）、取消（Cancel）。会比 2&#x2F;3PC 更加好理解，因此他三个阶段功能如下：</p>
<ol>
<li>Try：检查所有业务的 <strong>一致性</strong>、并预留业务资源保证在事务执行时不会被其他事务打扰</li>
<li>Confirm：使用 Try 阶段预留的业务资源来执行业务</li>
<li>Cancel：取消执行业务，并释放 Try  阶段预留资源</li>
</ol>
<h3 id="消息中间件模式"><a href="#消息中间件模式" class="headerlink" title="消息中间件模式"></a>消息中间件模式</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210604031513.png"><br>通过引入消息中间件，可以进行异步处理、系统解耦、事务管理。从而解决多个系统之间同步通信所造成的阻塞，并将这些耦合在一起。消息中间件模式与 TCC 同样是最终一致性来管理事务，而 2&#x2F;3PC 则是强一致。 </p>
<p>在这个过程中，主要有三个要素，分别是将数据消息投递到中间件服务器中，通过消息确认机制保证成功投递。然后通过消费者可以正常使用消息，最后来保证第一个事务先执行。</p>
<p>目前世面上主流的消息中间件有 Redis、ActiveMQ、RabbitMQ、RocketMQ、Kafka等。</p>
<h3 id="Saga-模式"><a href="#Saga-模式" class="headerlink" title="Saga 模式"></a>Saga 模式</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210604031520.png"><br>Saga是根据 Hector 和 Kenneth 与 1987 年所发表的论文 《sagas》作为理论基础而出现的补偿协议。</p>
<p>Saga 模式其主要的就是 <strong>将长事务拆分为多个且可交错运行的子事务合集</strong> 而这些子事务都保持一定的一致性，都将由 saga 事务协调器来进行协调。</p>
<p>如果每一个子事务都正常结束，则整个事务完成。假设有某个子事务失败，那么则整个事务失败，并根据相反顺序来执行补偿步骤。</p>
<p>需要注意的是，Saga 由一系列的 T 事务组成，每个 T都对应一个补偿动作 C，用于撤销 T 所造成的结果。</p>
<h4 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h4><h5 id="向后恢复"><a href="#向后恢复" class="headerlink" title="向后恢复"></a>向后恢复</h5><p>向后恢复（backward recovery），补偿所有已完成事务。如果某一个子任务失败，则之前所有成功的子事物即 <strong>整个saga执行结果撤销</strong>。</p>
<h5 id="向前恢复"><a href="#向前恢复" class="headerlink" title="向前恢复"></a>向前恢复</h5><p>向前恢复（forward recovery），将失败的事务重试，假设所有失败的业务最终都会成功，在这种情况下就没有补偿事务什么事情了，常见与必须成功的场景。‘</p>
<h3 id="Paxos-一致性算法"><a href="#Paxos-一致性算法" class="headerlink" title="Paxos 一致性算法"></a>Paxos 一致性算法</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210604031525.png"><br>Paxos 算法由 Lamport 所提出的一种基于消息传递的分布式一致性算法，也被认为是类似算法中最为有效的，因此使其获得了 2013年图灵奖，他的主要作用就是 <strong>在分布式系统中就某个值，来达成一致</strong>。</p>
<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p>首先在 Paxos 算法中最终要的就是角色，非常重要，主要有三个，分别为：</p>
<ol>
<li>提议者（Proposer）</li>
<li>决策者（Acceptor ）</li>
<li>学习者（Learner）</li>
</ol>
<h4 id="决策"><a href="#决策" class="headerlink" title="决策"></a>决策</h4><p>首先，<strong>提议者（Proposer）</strong> 提出议案（Proposal），信息中包含了案件编号（Proposer id）以及提议的值（Value）</p>
<p>之后 <strong>决策者（Acceptor）</strong> 参与决策，回应 <strong>提议者（Proposer）</strong> 提案，如果收到的提案（Proposal）获得多数 <strong>提议者（Acceptor）</strong> 的接受，则该提案被批准</p>
<p>最后 <strong>学习者（Learner）</strong> 来学习从会议中获得到达成一致的提案（value）。</p>
<blockquote>
<p>2F+1 我们可以理解为，假设要是决策者 5个 同意 5个拒绝，那么就不会构成会议的决策。在这种情况下，如果有2倍的 决策者 人数并加一，就可以保证信息的正确，使得会议正常进行。</p>
</blockquote>
<p>Paxos 算法允许运行在宕机故障的异步系统内，也不要求可靠的消息传递，他使用了多数机制保证了 2F（faulty）+1 的容错，即 2F（faulty）+1 个节点最多允许 F 个节点出现问题。</p>
<h1 id="Spring-cloud-跨服务查询与微服务部署概述"><a href="#Spring-cloud-跨服务查询与微服务部署概述" class="headerlink" title="Spring cloud 跨服务查询与微服务部署概述"></a>Spring cloud 跨服务查询与微服务部署概述</h1><h2 id="跨服务之间查询"><a href="#跨服务之间查询" class="headerlink" title="跨服务之间查询"></a>跨服务之间查询</h2><p>在微服务中，如果需要服务之间与服务之间进行数据的查询，可以被称之为 “跨服务”，而进行这个过程的有两种，分别为 API 和 CQRS模式两种。</p>
<h3 id="API-组合器模式"><a href="#API-组合器模式" class="headerlink" title="API  组合器模式"></a>API  组合器模式</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210605021404.png"><br>API 组合器模式由两个或多个服务提供者组成，服务提供者拥有数据服务（即数据库），API 组合器通过查询每个服务提供者的 API 结果并组合，来实现从多个服务检索数据库的查询。</p>
<h3 id="CQRS"><a href="#CQRS" class="headerlink" title="CQRS"></a>CQRS</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210605021412.png"><br>命令查询职责分离（CQRS，Command Query Responsibility Segregation），是由 Eiffel 语言之父 Betrand Meyer 提出的概念，简单来讲就是将业务上分离了 <strong>读（query）和写（command）的行为</strong>，就比人的睡和醒是两种行为。</p>
<ol>
<li>命令（Command），不返回任何结果（void），但会改变对象状态，指增加、删除、修改</li>
<li>查询（Query）用于返回结果（void），不会改变对象状态</li>
</ol>
<p>因此 CQRS 中主要强调 <strong>读（Query）和写（Command）的分离</strong> ，可能当查询数据会有一些问题，如时间过时的数据问题，可以通过使用事件（Event）机制来解决问题并修改查询数据源。</p>
<h2 id="微服务部署"><a href="#微服务部署" class="headerlink" title="微服务部署"></a>微服务部署</h2><h3 id="部署模式"><a href="#部署模式" class="headerlink" title="部署模式"></a>部署模式</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210606003230.png"><br>微服务的部署主要可以分为四种，这四周部署模式中主要通过下述方式进行：</p>
<ol>
<li>WAR、JAR 包运行</li>
<li>服务部署虚拟机运行</li>
<li>通过 Docker 或 Kubernetes 等容器化技术进行微服务部署</li>
<li>Serverless 无服务器部署</li>
</ol>
<blockquote>
<p>无服务器（Serverless）通过应用 <strong>使用第三方功能或服务</strong>，不需要管理服务器，但不代表他不需要服务器，主要包括了：</p>
<p> <strong>功能即服务（Function as a Service，FaaS）</strong> 简单来讲就是功能运行在独立容器中，基于事件驱动，由第三方托管功能。</p>
<p> <strong>后端即服务（Backend as a Service，Baas）</strong> 使用第三方服务来达到目的。</p>
</blockquote>
<h3 id="升级（维护）模式"><a href="#升级（维护）模式" class="headerlink" title="升级（维护）模式"></a>升级（维护）模式</h3><h4 id="蓝绿部署"><a href="#蓝绿部署" class="headerlink" title="蓝绿部署"></a>蓝绿部署</h4><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210606003239.png"><br>蓝绿部署（Blue-green deployment），可以称之为 <strong>可不停机维护</strong>，主要分为蓝（Blue）和绿（Green）两个版本，其流程如下：</p>
<ol>
<li>当更新时，将所有访问流量分给绿色部分来提供服务，从而升级蓝色集群。</li>
<li>当蓝色集群升级完后，来将绿色流量切换到蓝色集群，从而升级绿色集群</li>
<li>升级完成后将访问流量分配到全部集群中</li>
</ol>
<h4 id="滚动部署"><a href="#滚动部署" class="headerlink" title="滚动部署"></a>滚动部署</h4><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210606003246.png"><br>滚动部署（Rolling deployment），指每次只一个或多个服务暂停。进行更新，后将此服务继续投入使用，直到集群中所有服务都被更新或完成为止。</p>
<h4 id="金丝雀发布（灰度发布）"><a href="#金丝雀发布（灰度发布）" class="headerlink" title="金丝雀发布（灰度发布）"></a>金丝雀发布（灰度发布）</h4><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210606003252.png"></p>
<blockquote>
<p>为什么叫金丝雀发布？<br>在以前矿工开矿的时候，需要在下矿洞前需要检查下方是否有毒气，矿工会放一只金丝雀进去，来去探路是否有毒气。</p>
</blockquote>
<p>金丝雀发布也叫灰度发布（Canary release &#x2F; Grayscale release），其主要是一部分更新，一部分使用老版本，当新版本用户没什么建议的话，则全部将迁移到新版本中。</p>
<h1 id="Spring-cloud-云原生概述"><a href="#Spring-cloud-云原生概述" class="headerlink" title="Spring cloud 云原生概述"></a>Spring cloud 云原生概述</h1><p>目前我们所谈论的云原生大多数分为两个，一个由 spring 开发公司 <strong>Pivotal</strong> 所定义的，另一个则是由谷歌所牵头成立的 <strong>云原生计算基金会</strong> （CNCF，Cloud Native Computing Foundation）。</p>
<p>本文我们仅理解 Pivotal 公司和部分 CNCF 所定义的为服务，其主要概述主要分为四类，分别为：</p>
<ol>
<li>微服务</li>
<li>DevOps<br><del>3. CI\CD（持续集成和持续交付</del>）</li>
<li>容器化</li>
</ol>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>读者可通过下一篇文章深度和实践中了解到微服务到底可以做什么，他的作用都会被理解，主要明确服务之间的解藕，多个服务集群。</p>
<h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><p>DevOps（Development Opertainos）组合，即开发和运维组合，可以减少应用程序发布的风险。</p>
<blockquote>
<p>CI\CD（Continuous integration \ Continuous deployment），及持续集成和持续交付的所略词，其主要概念是通过应用程序的共建、测试和部署中实施自动化，在开发和运营团队架起桥梁，也是构成 DevOps 关键之一。</p>
</blockquote>
<h2 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h2><p>容器化即以容器为基础，在容器中运行的进程和应用，其 Docker 是应用最为广泛的容器引擎。通过容器封装让进程和应用成为一个独立的单元，并实现除了高水平的资源隔离，简化了维护。</p>
<p>除此之外还有 kubernetes 容器编排系统，主要用于容器管理和容器之间的负载均衡，都是实现容器话的关键。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>本文使用 <strong>1.8.0_202</strong> 和 Maven <strong>3.6.0</strong> 进行演示和构建，读者可自行进行安装其环境。此时我们需要使用 <strong>Spring Assistant</strong>，有两种方式可以进行安装，分别是从 jetbrains 内的 插件社区中 <a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/10229-spring-assistant">https://plugins.jetbrains.com/plugin/10229-spring-assistant</a> 进行获取，也可从 <strong>Plugins</strong> 内直接进行安装，搜索 <strong>Spring Assistant</strong> 之后重启 IDEA 即可。</p>

	

	

</article>




	<article>
	
		<h1><a href="/2022/04/21/java/spring cloud/13.Spring Cloud Alibaba Sentinel/">Spring Cloud Aliababa Sentinel</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2022-04-21</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-none-link" href="/tags/java/" rel="tag">java</a> <a class="article__tag-none-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a>
			</span>
		
	</div>

	

	
		<p>Sentinel 是 Alibaba Spring Cloud 微服务组件之一，他以 流量为切入点，主要实现流量控制、熔断降级、系统负载保护等多个维度来保证服务的稳定性，因此他还提供了机器发现、健康情况、监控、规则管理和推送等功能，并提供了一个可视化控制页面 Sentinel Dashboard，可前往 <a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/releases/tag/1.8.2">https://github.com/alibaba/Sentinel/releases/tag/1.8.2</a> 进行下载，之后可以通过下述命令启动（Sentinel Dashboard 的帐号密码同样都为 <code>sentinel</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo java -Dserver.port=9899 -Dcsp.sentinel.dashboard.server=localhost:9899 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.8.2.jar</span><br></pre></td></tr></table></figure>

<h2 id="限流模式"><a href="#限流模式" class="headerlink" title="限流模式"></a>限流模式</h2><h3 id="直接失败"><a href="#直接失败" class="headerlink" title="直接失败"></a>直接失败</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210801213452.png"></p>
<blockquote>
<p>通过 postman 进行测试</p>
</blockquote>
<h4 id="直接限流"><a href="#直接限流" class="headerlink" title="直接限流"></a>直接限流</h4><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210801213505.png"></p>
<p>当实例运行后，进入该实例中，在控制台中的流控规则中添加一个控流规则，并设置 QPS 为 1，并选择直接控流模式，而这个规则所达到的效果就是让超过阀值的请求直接失效，因此我们需要在项目中添加所需依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在配置中我们依然只需要连接 Sentinel 控制台即可，并配置项目的名称，这将会在控制台中进行显示状态以及管理等。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">alibaba-sentinel</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:9899</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8210</span></span><br></pre></td></tr></table></figure>

<h5 id="自定义埋点"><a href="#自定义埋点" class="headerlink" title="自定义埋点"></a>自定义埋点</h5><p>所谓 “埋点” 我们可以理解为当用户访问特定的某个点，也就是监听这个点是否被用户所访问，在 Sentinel 中，我们可以通过 <code>@SentinelResource</code> 依赖中的埋点与 Sentinel 控制台中所增加的规则进行绑定，从而实现直接限流的效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.annotation.SentinelResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义埋点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">heyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hey&quot;)</span></span><br><span class="line">    <span class="meta">@SentinelResource(&quot;hey&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Server ok!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当这完成之后，我们在 Sentinel 控制台中所增加的控流规则 QPS&#x3D;1 当超过这个阀值的时候，该请求也会快速失败。</p>
<h4 id="关联限流"><a href="#关联限流" class="headerlink" title="关联限流"></a>关联限流</h4><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210801213520.png"></p>
<p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210801213529.png"></p>
<p>关联限流简单理解就是，当我访问 <code>test/one</code> 的 QPS&#x3D;1 的阀值过了以后，那么 <code>test/two</code> 这个接口就无法进行访问，因此我们在直接限流的基础上可以不需要设置埋点，直接添加两个接口即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关联限流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">heyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/one&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">one</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Server one ok!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/two&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">two</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Server two ok!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链路限流"><a href="#链路限流" class="headerlink" title="链路限流"></a>链路限流</h4><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210801213543.png"></p>
<p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210801213555.png"><br>链路路由主要的作用就是，假设我们的接口都使用一个方法接口，那么在 Sentinel 中所填写的控流模式的入口资源，当入口资源超过 QPS 阀值时，那么将会被限流，但同样使用方法接口的另一个接口不会受此影响，为实现链路路由，我们需要添加如下依赖和增加配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sentinel-web-servlet&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>之后在配置文件中将是否统一网络上下文中选择 false：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">alibaba-sentinel</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:9899</span></span><br><span class="line">      <span class="attr">web-context-unify:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8210</span></span><br></pre></td></tr></table></figure>

<h5 id="server"><a href="#server" class="headerlink" title="server"></a>server</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.annotation.SentinelResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sentinelServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SentinelResource(&quot;message&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sentinelTest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sentinel is Test.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.server.sentinelServer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链路限流</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">heyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> sentinelServer sentinelServer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/one&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">one</span><span class="params">()</span> &#123;</span><br><span class="line">        sentinelServer.sentinelTest();</span><br><span class="line">        System.out.println(<span class="string">&quot;Server two ok!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Server one ok!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/two&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">two</span><span class="params">()</span> &#123;</span><br><span class="line">        sentinelServer.sentinelTest();</span><br><span class="line">        System.out.println(<span class="string">&quot;Server two ok!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Server two ok!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Warm-Up"><a href="#Warm-Up" class="headerlink" title="Warm Up"></a>Warm Up</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210801213631.png"></p>
<p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210801213637.png"></p>
<p>Warm Up 限流的主要作用就是为了应对猛烈的流量请求，分批次的进行处理，之后慢慢加流量，而不是向 DDos 一样直接就把服务干崩溃了。做一个很形象的比喻，我们吃饭的时候都是嚼了好几下才开始咽下去的，而一些猛人吃饭跟喝水一样，最终导致食物卡到了喉咙了，而这种情况在限流中也同样存在，因此 Warm Up 就很好的解决了这个问题。</p>
<h3 id="排队限流"><a href="#排队限流" class="headerlink" title="排队限流"></a>排队限流</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210801213642.png"></p>
<p>排队等待的限流模式主要通过超时时间，也就是每个请求的处理时常，以此让服务匀速处理请求而不是直接拒绝请求的作用，在新的控流规则中，我们设置 QPS 为 4，而超时时间（每个请求的处理时间为 1000ms），从而我们的服务性能可以处理，但如果超时时间设置为 100ms 时，则会发现被拦截的请求很多，这是因为服务的处理性能达不到预设的超时时间而造成的。</p>

	

	

</article>




	<article>
	
		<h1><a href="/2022/04/21/java/spring cloud/12.Spring Cloud Alibaba Nacos/">Spring Cloud Alibaba Nacos</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2022-04-21</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-none-link" href="/tags/java/" rel="tag">java</a> <a class="article__tag-none-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a>
			</span>
		
	</div>

	

	
		<p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210801164139.png"><br>Spring Cloud Alibaba 是一个遵循 Spring Cloud 变成规范的框架，也就是 Alibaba 所推出的微服务解决方案，他主要分为 Sentinel（流量控制）、Nacos（服务发现）、RocketMQ（分布式消息系统）、Dubbo（高性能 Java RPC 框架）、Seata（高性能微服务事务解决方案）、ACM（配置中中心）、OSS（对象存储服务）、SchedulerX（分布式任务调度）、SMS（短信服务）</p>
<p>Alibaba 对为 Spring Cloud 的贡献同样可以与 Netfilx 相同的产品都有类似的解决方案，但在 Spring Cloud 中 Netfilx 的贡献要比 Alibaba 早上许多，因此通常 Alibaba 的解决方案依然可以替换掉 Netfilx 的产品，但 Netfilx 同样也可以替换掉 Alibaba 的解决方案，与其相比之下 Alibaba 的解决方案更加的简洁，通常一个项目可以代替很多个 Netfilx 的子项目。</p>
<p>Nacos 是 Alibaba Spring Cloud 中用于构建微服务应用与服务治理的配置管理组建，与 Eureka、Conusl 同样分为服务中心、服务提供者、服务消费者等三个角色，除此之外还可以直接实现配置中心的服务。</p>
<p>在实现服务提供者和消费者之前，我们首先需要通过 Nacos 仓库来下载其发行版本的服务中心，需要注意的是环境环境依赖是：</p>
<ol>
<li>64bit 支持 Linux\Unix\Mac\Windows（官方推荐 Linux\Mac\Unix）</li>
<li>JDK 1.8+</li>
<li>Maven 3.2.+</li>
</ol>
<p>满足依赖环境后可以通过 <a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos/releases/tag/2.0.3">https://github.com/alibaba/nacos/releases/tag/2.0.3</a> 来获取你想要的版本进行下载。</p>
<p>之后解压进入 <code>bin</code> 目录，并运行 <code>./startup.sh -m standalone</code> 命令以启动 Nacos，并访问 <a target="_blank" rel="noopener" href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> 即可登入 nacos 的控制台，帐号密码均为 <code>nacos</code>，因此服务中心的地址为 <code>localhost:8848</code></p>
<h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210801164149.png"><br>我们首先创建两个服务提供者，并连接服务中心，之后进行配置，在默认情况下我们需要引入 spring-boot-starter-web、spring-cloud-starter-alibaba-nacos-discovery 依赖以作为必要的服务支撑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>同样的我们需要进行配置连接服务中心以及名称等，以便在微服务系统中发现该功能是那个服务所提供的，因此好进行改进和调整，配置后我们还需要在启动类中添加 <code>@EnableDiscoveryClient</code> 依赖</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">localhost-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8210</span></span><br></pre></td></tr></table></figure>

<h4 id="heyController"><a href="#heyController" class="headerlink" title="heyController"></a>heyController</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提供者控制器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">heyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.application.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hey&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sty</span> <span class="operator">=</span> <span class="string">&quot;This is Provider: &quot;</span> + appName + <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> sty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上所述我们的服务提供者所提供的基础服务已经构建完成，在演示中我们构建的是两个服务提供者，都提供同样的功能，端口为 <code>8210～8211</code> ，为两个服务提供者，之后我们可以编写服务消费者。</p>
<h3 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210801164200.gif"></p>
<p>至于服务消费者，我们同样的需要引入 <code>spring-cloud-starter-alibaba-nacos-discovery</code> 依赖以及负载均衡 feign 依赖，和一些基础服务提供依赖，来完成服务消费者的构建，在此之前我们需要在启动类中添加 <code>@EnableDiscoveryClient</code> 注解并完善配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>配置文件的主要作用同样是配置服务名称以及连接服务中心等：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">localhost-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8310</span></span><br></pre></td></tr></table></figure>

<h4 id="heyController-1"><a href="#heyController-1" class="headerlink" title="heyController"></a>heyController</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.ServiceInstance;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalancerClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">heyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.application.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hey&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">echoApplication</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServiceInstance</span> <span class="variable">serviceInstance</span> <span class="operator">=</span> loadBalancerClient.choose(<span class="string">&quot;localhost-provider&quot;</span>);</span><br><span class="line">        <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> serviceInstance.getUri();</span><br><span class="line">        <span class="type">String</span> <span class="variable">callService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>().getForObject(uri + <span class="string">&quot;/hey&quot;</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> callService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210801164206.png"></p>
<p>相对与之前的 Spring Cloud Config ，Alibaba 所提供的 Spring Cloud Aliababa Config 主要依赖于服务中心的分发与配置，同时还支持配置动态刷新，以及达到和 Spring Cloud Config 相同效果的配置文件应用，只需要依赖 <code>spring-cloud-starter-alibaba-nacos-config</code> 即可，在此之前我们还需要在启动类中加入 <code>@EnableDiscoveryClient</code> 依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在此之前，我们需要在服务中心中新建一个 <code>.properties</code> 类型的文件，当然他默认支持了 TEXT、JSON、XML、YAML、HTML、Properties 等配置格式，我们只需要填写配置信息和 <code>Data ID</code> 即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.version=rsa</span><br><span class="line">message=Spring Cloud Alibaba Config Server</span><br><span class="line">server.port=9510</span><br></pre></td></tr></table></figure>

<h3 id="bootstrap-yml-amp-application-yml"><a href="#bootstrap-yml-amp-application-yml" class="headerlink" title="bootstrap.yml &amp; application.yml"></a>bootstrap.yml &amp; application.yml</h3><h4 id="bootstrap-yml"><a href="#bootstrap-yml" class="headerlink" title="bootstrap.yml"></a>bootstrap.yml</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">refreshable-dataids:</span> <span class="string">server-config-example.properties</span></span><br></pre></td></tr></table></figure>

<p>我们通过 <code>refreshable-dataids</code> 来绑定配置文件的名称，之后通过服务中心进行获取，因为是从服务中心直接获取，从而省去了很多配置。</p>
<h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">localhost-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8410</span></span><br></pre></td></tr></table></figure>

<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210801164216.png"><br>控制器主要作用就是通过服务中心以及配置所绑定的文件，来获取到服务中心的配置文件信息，并通过指定接口来进行输出，当一切开始运行后访问 <a target="_blank" rel="noopener" href="http://localhost:9510/hey">http://localhost:9510/hey</a> 即可看到从服务中心和控制器所输出的信息。</p>
<h4 id="ServerConfigController-java"><a href="#ServerConfigController-java" class="headerlink" title="ServerConfigController.java"></a>ServerConfigController.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  获取服务中心配置文件信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/8/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerConfigConortller</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.version&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appVersion;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hey&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;application: &quot;</span> + appVersion + <span class="string">&quot; message: &quot;</span> + message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
	

	

</article>




	<article>
	
		<h1><a href="/2022/04/21/java/spring cloud/11.Spring cloud Config/">Spring cloud Config</a></h1>
	
	<div class="article__infos">
		<span class="article__date">2022-04-21</span><br />
		
		
			<span class="article__tags">
			  	<a class="article__tag-none-link" href="/tags/java/" rel="tag">java</a> <a class="article__tag-none-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a>
			</span>
		
	</div>

	

	
		<p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210726153838.png"><br>Spring Cloud Config 可以为分布式系统中外部化配置提供服务器端和客户端的支持，通过 Config Service 即配置中心，可以集中管理所有环境中应用程序配置，这其中主要用于集中管理信息的组件，用于提供配置变更、配置推送、历史版本管理以及灰度发布、配置变更审计等主要的功能，以此来降低分布式系统中所管理和配置信息的成本。</p>
<p>其实 Spring Cloud Config 说简单一点就是通过本地（含 Git&#x2F;远程代码仓库）来获取配置信息，然后服务提供者A、B…… 从配置中心获取服务，在这个过程中有一个 <code>Spring Cloud Bus</code> 即消息总线，用于通知服务提供者需要获取配置。</p>
<p>目前主流的配置中心有 Spring Cloud Config、Apollo、Nacos、Disconf 等项目，其中 Spring Cloud Config 与 Disconf 是这些项目中最早开源的项目。</p>
<p>但这些项目中，Spring Cloud Config 他的功能全面，以及无缝贴合 Spring 体系，因此大受欢迎。</p>
<h2 id="Config-Server"><a href="#Config-Server" class="headerlink" title="Config Server"></a>Config Server</h2><h3 id="localhost"><a href="#localhost" class="headerlink" title="localhost"></a>localhost</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210726153948.png"><br>目前主要且流行的方式就是通过 git 仓库来获取多个或多个配置文件，并通过对称&#x2F;非对称加密来对密文转为明文，这都的易于 Spring Cloud Config 的特性，如果只满足简单的获取配置文件只需要添加 <code>spring-cloud-config-server</code> 依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>之后在其启动类中加入注解 <code>@EnableConfigServer</code>，并通过 <code>application.yml</code> 全局 Spring 配置中设置仓库地址和帐号密码</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://gitee.com/sif_one/spring-cloud-config</span></span><br><span class="line">          <span class="attr">search-paths:</span> <span class="string">config-repositories</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">xxx</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">xxx</span></span><br><span class="line">        <span class="attr">encrypt:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment"># 是否进行解密</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8210</span></span><br></pre></td></tr></table></figure>


<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>对于 git 仓库中的配置文件，需要注意的是 <code>-</code> 在访问时会被 <code>/</code> 所代替，如你的配置文件名为 <code>config-dev.properties</code>，那么所请求的 URI 就为 <a target="_blank" rel="noopener" href="http://localhost:8210/config/dev">http://localhost:8210/config/dev</a>，当然这是 json 格式的，如果想以常用的格式进行返回，可将 URI 改为其配置文件名 <a target="_blank" rel="noopener" href="http://localhost:8210/config-dev.properties">http://localhost:8210/config-dev.properties</a> 即可。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app.version</span>=<span class="string">dev</span></span><br><span class="line"><span class="attr">message</span>=<span class="string">Spring Cloud Config Demo</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">&#123;cipher&#125;32fd20f46a9c00238236ff530349eefb1dbaad99374c62276f266c326fa8e1ec</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8017</span></span><br></pre></td></tr></table></figure>

<h2 id="Config-Server-Client"><a href="#Config-Server-Client" class="headerlink" title="Config Server Client"></a>Config Server Client</h2><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210729211317.png"><br>Spring cloud config client  的主要作用就是通过配置中心来获取配置并使用，主要通过 <code>spring-cloud-starter-config</code> 依赖来进行实现，并通过 <code>bootstrap.yml</code> 文件来达到配置文件切换的效果，最后在使用控制器进行输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="bootstrap-yml-and-application-yml"><a href="#bootstrap-yml-and-application-yml" class="headerlink" title="bootstrap.yml and application.yml"></a>bootstrap.yml and application.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">rsa</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:8210</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>在 bootstrap.yml 文件中，你可以通过 <code>profile</code> 来切换配置文件的数据，也就是 <code>name(config)</code> 和 <code>profile(rsa)</code>，这也是我们配置文件 <code>config-rsa</code> 拼合而成。当然你也可以在 <code>application.yml</code> Spring 全局配置文件中来为其添加应用名称，毕竟他才是权重第一的配置文件。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">SpringCloudConfigClient</span></span><br></pre></td></tr></table></figure>

<h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取配置中心的数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kunlun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">heyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;app.version&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hey&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;message:&quot;</span> + message + <span class="string">&quot;:&quot;</span> + <span class="string">&quot; version:&quot;</span> + version;</span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="配置文件的加密"><a href="#配置文件的加密" class="headerlink" title="配置文件的加密"></a>配置文件的加密</h2><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210726153913.png"></p>
<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210726154017.png"></p>
<p>Config Server 除了管理配置文件和版本管理之外，还支持对文件的对称和非对称加密，其中对称加密简单的来将就是采用单个密钥的方式进行加密，也就是说一个密钥可以加密和解密。</p>
<p>而非对称加密就与对称加密不同了，非对称加密算法分为公钥和私钥，如果用公钥对数据进行加密，那么只能通过私钥才可解密。目前有很多文章说需要使用新版本的 JDK 或者通过 JCE 来进行解决，当然这也是解决方法之一，在新版的 Spring 中，需要引入除 <code>spring-cloud-config-server</code> 之外的新依赖，即 <code>spring-cloud-starter-bootstrap</code> 依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>此时 <code>spring-cloud-starter-bootstrap</code> 会提供三个端口，分别用于加密、解密、检查等方式进行对称加密的操作：</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>Name</th>
<th>Info</th>
<th>Uri</th>
<th>Method</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>&#x2F;encrypt&#x2F;status</td>
<td>检查加密密钥是否设置成功</td>
<td><a target="_blank" rel="noopener" href="http://localhost:8210/encrypt/status">http://localhost:8210/encrypt/status</a></td>
<td>GET</td>
</tr>
<tr>
<td>2</td>
<td>&#x2F;encrypt</td>
<td>加密内容</td>
<td><a target="_blank" rel="noopener" href="http://localhost:8210/encrypt">http://localhost:8210/encrypt</a></td>
<td>POST</td>
</tr>
<tr>
<td>3</td>
<td>&#x2F;decrypt</td>
<td>解密内容</td>
<td><a target="_blank" rel="noopener" href="http://localhost:8210/decrypt">http://localhost:8210/decrypt</a></td>
<td>POST</td>
</tr>
</tbody></table>
<p>在原有的 Spring Cloud Config 基础上，我们只需要新建一个 <code>bootstrap.properties</code> 文件并写入密钥，这主要的作用就是，你请求这个接口显示的是明文，而没有密钥的客户端发起请求返回的则是密文。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">encrypt.key</span>=<span class="string">hey</span></span><br></pre></td></tr></table></figure>

<p>当然你如果有不良癖好喜欢密文的话，也可以通过 <code>encrypt</code> 来停止 Spring cloud config 的直接翻译，这时返回的则是密文信息：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">encrypt:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment"># 是否进行解密</span></span><br></pre></td></tr></table></figure>

<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210726154028.png"><br>至于非对称加密则需要通过 <code>keytools </code> 来新建一个密钥，之后生成一个密钥移动到 <code>resourcs</code> 目录下，并在 bootstrap 全局配置文件 <code>bbootstrap.applicatiyon</code> 下填写相关的配置信息即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkeypair -alias &quot;spring-cloud-config&quot; -keypass &quot;keypass&quot; -keyalg &quot;RSA&quot; -storepass &quot;stropess&quot; -keystore &quot;spring-cloud-config.jks&quot;</span><br></pre></td></tr></table></figure>

<p>其中上述命令最为关键的部分则是 <code>alias（别名）</code> 、<code>keypass（密钥口令）</code>、<code>storepass（密钥库口令）</code> 这三类主要配置，将会在配置文件中进行使用以验证身份，而 <code>-keylag</code> 则主要表示密钥的类型为 RSA 加密算法。</p>
<blockquote>
<p>RSA是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）在1977年一起提出的，当时他们三人都在麻省理工学院工作，RSA 就是他们三人姓氏开头字母拼在一起组成的。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 密钥位置</span><br><span class="line">encrypt.key-store.location=classpath:/spring-cloud-config.jks</span><br><span class="line"># 密钥别名</span><br><span class="line">encrypt.key-store.alias=spring-cloud-config</span><br><span class="line"># 密钥库密码</span><br><span class="line">encrypt.key-store.secret=</span><br><span class="line"># 密钥密码</span><br><span class="line">encrypt.key-store.password=</span><br></pre></td></tr></table></figure>

<p>与对称加密一样，可以通过之前的三个端点来进行加密、解密、状态检查等服务：</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>Name</th>
<th>Info</th>
<th>Uri</th>
<th>Method</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>&#x2F;encrypt&#x2F;status</td>
<td>检查加密密钥是否设置成功</td>
<td><a target="_blank" rel="noopener" href="http://localhost:8210/encrypt/status">http://localhost:8210/encrypt/status</a></td>
<td>GET</td>
</tr>
<tr>
<td>2</td>
<td>&#x2F;encrypt</td>
<td>加密内容</td>
<td><a target="_blank" rel="noopener" href="http://localhost:8210/encrypt">http://localhost:8210/encrypt</a></td>
<td>POST</td>
</tr>
<tr>
<td>3</td>
<td>&#x2F;decrypt</td>
<td>解密内容</td>
<td><a target="_blank" rel="noopener" href="http://localhost:8210/decrypt">http://localhost:8210/decrypt</a></td>
<td>POST</td>
</tr>
</tbody></table>
<p>我们在 git 仓库重新建立一个配置文件，他主要通过非对称加密作为密文，之后通过我们的密钥来进行解密的这么一个流程：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app.version</span>=<span class="string">rsa</span></span><br><span class="line"><span class="attr">message</span>=<span class="string">Spring Cloud Config Demo</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">&#123;cipher&#125;AQA15miINQvSMr5kJorYoX2MLH+1XgjBAGrJKPJWzAvaUhxfrd6So0skCEXjiidn/Vgf+aWCcz17pugBoRqEeDU6XLyu1tS3dAyNE/z7vbyEcp+DsJOEqHiHnr3VqzrhQTJheJOibkskvd8kJt6WP4F9Tl8qyen6mOz+4/Ce4x9iCzPoWTO2Yc+jXJFAjOSB02/kh1wnqAdyc0s7cDYLjjR+FBSMFjFJXV0Qax28hZNjjdlUb/Hy+8mPaSAQbipc9FIKB+dQaSAABYCviscHz7XkjpfmQN3qOAYiMum851OP1OOn8KHGpUu1u7D8ET+404iAHjNPTKh/As8T9A92Av73YE6b8Dj3m9wZf4hCUyEMFUpo0kffw9ThOAzVgR1RnNY=</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8017</span></span><br></pre></td></tr></table></figure>


<h2 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h2><p>Spring Cloud Bus 将会用于自动刷新配置，并且可以管理和传播分布式项目中的消息，利用消息中间件广播的机制传播可以实现将消息连接整个集群，他目前支持 Kafka 和 RabbitMQ，其中目前主要流行的就是这两个项目。</p>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210729211335.png"><br>RabbitMQ 是一个开源的消息代理项目，即面向消息的中间件，采用 Erlang 语言来进行编写，因此我们除了安装 RabbitMQ 之外还需要安装 Erlang 。</p>
<p>对于使用 debian 系的 Linux 用户，可以通过使用 <code>apt-get install erlang</code> 直接进行安装 erl，之后同样的安装 RabbitMQ Server 并运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install rabbitmq-server</span><br><span class="line">systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure>

<p>运行之后就开始进行配置 RabbitMQ 了，这里面主要的就是配置帐号密码以及权限和安装可视化插件：</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>Name</th>
<th>Info</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>rabbitmq-plugins enable rabbitmq_management</code></td>
<td>安装可视化插件</td>
</tr>
<tr>
<td>2</td>
<td><code>rabbitmqctl add_user root toor</code></td>
<td>添加 root 帐号密码为 toor</td>
</tr>
<tr>
<td>3</td>
<td><code>set_user_tags root administrator</code></td>
<td>将 root 帐号设置为管理</td>
</tr>
<tr>
<td>4</td>
<td><code>set_permissions -p / root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code></td>
<td>为 root 帐号添加写入权限</td>
</tr>
<tr>
<td>5</td>
<td><code>rabbitmqctl list_permissions</code></td>
<td>查看当前的当前的权限列表</td>
</tr>
</tbody></table>
<p>值得注意的是，当 RabbimtMQ 配置完成后，他会提供三个非常重要的端口，分别为 <code>5672\25672\15672</code> 在本文中主要使用 <code>5672</code> 端口来进行 AMQP 连接接口，而 <code>15672</code> 用于 HTTP 访问接口，也就是监控中心，之后你可以将这个接口添加到 Config Server &amp; Client 配置文件中：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">SpringCloudConfigClient</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">toor</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">xxx</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br></pre></td></tr></table></figure>

<h3 id="Config-Server-1"><a href="#Config-Server-1" class="headerlink" title="Config Server"></a>Config Server</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210729211346.gif"><br>对于 Config Server ，我们可以理解在原有的基础上，增加了 Spring Cloud Config Bus 来实现配置文件更新和广播的作用，简单来讲就是默认情况下 Config Client 是无法实现自动更新的，只可以通过 Spring Config Bus 来进行实现发送 POST 来进行刷新客户端配置文件的应用，因此我们需要添加如下依赖（在原有的非对称加密的基础上配置 Config Server）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-integration-amqp&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.5.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h4><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210729211355.png"></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://gitee.com/sif_one/spring-cloud-config</span></span><br><span class="line">          <span class="attr">search-paths:</span> <span class="string">config-repositories</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">xxx</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">xxx</span></span><br><span class="line">        <span class="attr">encrypt:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment"># 是否进行解密</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">toor</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">xxx</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8210</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;bus-refresh&quot;</span></span><br></pre></td></tr></table></figure>


<p>之后打包上传到服务器之中，运行后即可通过使用 <code>http://111.67.201.159:8210/actuator/busrefresh</code> 接口来进行刷新客户端的配置，这是新版本中所提供的接口，当然你如果使用的是其他版本也可以通过访问 <code>/actuator</code> 端口来查看目前所支持的 Spring-Cloud-Bus 接口。</p>
<h3 id="Config-Client"><a href="#Config-Client" class="headerlink" title="Config Client"></a>Config Client</h3><p>Config Client 的主要作用就是获取到 Config Server 从 Git 仓库中的配置文件并运用，但是在不使用 Spring-Cloud-Config-Bus 的情况下，即使你将最新的配置文件上传了 Config Config 也不会进行更新，因此需要通过 Spring Cloud Config Bus 来进行实现，在原有的 Config CLient 基础上进行添加即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-config-client --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-integration-amqp&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.5.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="RefreshScope"><a href="#RefreshScope" class="headerlink" title="@RefreshScope"></a>@RefreshScope</h4><figure class="highlight plaintext"><figcaption><span>依赖主要的作用就是当 git 仓库发生改变或更新后，我们通过 Config server 所提供的 ```actuator/busrefresh``` POST 请求来刷新 Config Client 的配置文件，因此这个依赖主要的作用就是刷新的范围，我们在原有的 Config Server Client 基础上添加即可：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">package com.example.demo.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取配置中心的数据</span><br><span class="line"> *</span><br><span class="line"> * @author kunlun</span><br><span class="line"> * @date 2021/7/26</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">@RefreshScope</span><br><span class="line">public class heyController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;app.version&#125;&quot;)</span><br><span class="line">    private String version;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;message&#125;&quot;)</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/hey&quot;)</span><br><span class="line">    public String hey() &#123;</span><br><span class="line">        String string = &quot;message:&quot; + message + &quot;:&quot; + &quot; version:&quot; + version;</span><br><span class="line">        return string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然你也可以在启动类中进行添加  </p>
</blockquote>
<h4 id="application-yml-1"><a href="#application-yml-1" class="headerlink" title="application.yml"></a>application.yml</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">SpringCloudConfigClient</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">toor</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">xxx</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;bus-refresh&quot;</span></span><br></pre></td></tr></table></figure>

<p>配置文件中的 <code>management</code> 为开启此接口，默认的情况下是关闭的，需要通过配置文件中进行配置，之后即可访问，虽然在最新版本中不知道有没有什么作用，但是为了保险期间还是添加为好。</p>
<blockquote>
<p>新版本中 Spring Cloud Config Bus 所提供的 POST 更新接口为 <code>actuator/busrefresh</code></p>
</blockquote>
<h4 id="bootstrap-yml"><a href="#bootstrap-yml" class="headerlink" title="bootstrap.yml"></a>bootstrap.yml</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">rsa</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://xxx:8210</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>bootstrap 配置文件主要做的就是通过 <code>spring.cloud.config</code> 来链接配置中心，并通过配置中心所获取的配置文件来进行运用，最后配置完成后我们可以尝试修改配置文件信息，你可以全部接口都访问一遍看看最初的效果（除了 <code>actuator/busrefresh</code>），之后通过 <code>actuator/busrefresh</code> 接口以 POST 方式进行刷新，最后访问 Spring Cloud Config Client 所提供的 <code>/hey</code> 接口来查看是否刷新成功。</p>
<h3 id="WebHooks"><a href="#WebHooks" class="headerlink" title="WebHooks"></a>WebHooks</h3><p><img src="https://49812933408852955071488026628034-1301075051.cos.ap-nanjing.myqcloud.com/20210729211421.png"></p>
<p>WebHooks 主要的作用就是当推送到 git 仓库的时候 WebHooks 服务会将 POST 请求到对应的 uri 中，从而实现我们手动请求 POST 来刷新服务配置文件的效果。但在新版本中却请求失败，考虑其他不可抗拒的因素建议国内读者选择 Gitte，但 WebHooks 依然请求返回 <code>400</code> 如有读者解决可在下放进行评论。</p>

	

	

</article>





	<span class="different-posts">📖 <a href="/page/15">more posts</a> 📖</span>



	</main>

	<footer class="footer">
	<div class="footer-content">
		
	      <div class="footer__element">
	<p>欢迎来到我的 blog <br><br> 通过 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>+<a target="_blank" rel="noopener" href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a> 进行构建的，存放在 <a target="_blank" rel="noopener" href="https://github.com/vendanges/vendanges.github.io">Github</a> 上。</p>
</div>

	    
	      <div class="footer__element">
	<h5>Check out</h5>
	<ul class="footer-links">
		<li class="footer-links__link"><a href="/archives">Archive</a></li>
		
		  <li class="footer-links__link"><a href="/atom.xml">RSS</a></li>
	    
		<li class="footer-links__link"><a href="/about">about page</a></li>
		<li class="footer-links__link"><a href="/tags">Tags</a></li>
		<li class="footer-links__link"><a href="/categories">Categories</a></li>
	</ul>
</div>

	    

		<div class="footer-credit">
			<span>© 2022 John Doe | Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> | Theme <a target="_blank" rel="noopener" href="https://github.com/HoverBaum/meilidu-hexo">MeiliDu</a></span>
		</div>

	</div>


</footer>



</body>

</html>
